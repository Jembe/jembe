{"version":3,"sources":["componentApi/utils.js","componentApi/directives/for.js","componentApi/directives/bind.js","componentApi/directives/text.js","componentApi/directives/html.js","componentApi/directives/show.js","componentApi/directives/if.js","componentApi/directives/on.js","componentApi/directives/model.js","../../../node_modules/observable-membrane/dist/modules/observable-membrane.js","componentApi/observable.js","../../../node_modules/process/browser.js","../../../node_modules/node-libs-browser/node_modules/path-browserify/index.js","componentApi/magic/jmb.js","componentApi/component.js","componentApi/index.js","utils.js","morphdom/morphAttrs.js","morphdom/util.js","morphdom/specialElHandlers.js","../../../node_modules/path-browserify/index.js","morphdom/morphdom.js","morphdom/index.js","client.js","jembe.js"],"names":["domReady","Promise","resolve","document","readyState","addEventListener","arrayUnique","array","Array","from","Set","isTesting","navigator","userAgent","includes","checkedAttrLooseCompare","valueA","valueB","warnIfMalformedTemplate","el","directive","tagName","toLowerCase","console","warn","content","childElementCount","kebabCase","subject","replace","camelCase","match","char","toUpperCase","walk","callback","node","firstElementChild","nextElementSibling","debounce","func","wait","timeout","context","args","arguments","clearTimeout","setTimeout","apply","handleError","expression","error","Object","assign","tryCatch","cb","value","catch","e","saferEval","dataContext","additionalHelperVariables","call","Function","keys","values","saferEvalNoReturn","AsyncFunction","getPrototypeOf","constructor","methodReference","xAttrRE","isXAttr","attr","name","replaceAtAndColonWithStandardSyntax","test","getXAttrs","component","type","directives","attributes","filter","map","parseHtmlAttribute","spreadDirective","spreadObject","$data","concat","entries","i","sortDirectives","directiveOrder","sort","a","b","typeA","indexOf","typeB","normalizedName","typeMatch","valueMatch","modifiers","isBooleanAttr","attrName","booleanAttributes","startsWith","convertClassStringToArray","classList","filterFn","Boolean","split","TRANSITION_TYPE_IN","TRANSITION_TYPE_OUT","TRANSITION_CANCELLED","transitionIn","show","reject","forceSkip","__jmb_transition","attrs","showAttr","settingBothSidesOfTransition","transitionHelperIn","index","some","transitionClassesIn","transitionOut","hide","transitionHelperOut","transitionClassesOut","showCallback","transitionHelper","duration","modifierValue","origin","first","opacity","scale","second","hideCallback","key","fallback","rawValue","isNumeric","join","hook1","hook2","styleValues","cancel","opacityCache","style","transformCache","transform","transformOriginCache","transformOrigin","noModifiers","transitionOpacity","transitionScale","stages","start","during","transitionProperty","trim","transitionDuration","transitionTimingFunction","end","cleanup","transition","ensureStringExpression","evaluateReturnExpression","transitionClasses","find","classesDuring","classesStart","classesEnd","originalClasses","__jmb_original_classes","add","remove","finish","once","isConnected","nextFrame","requestAnimationFrame","Number","getComputedStyle","animationDuration","isArray","isNaN","called","handleForDirective","templateEl","initialUpdate","extraVars","iteratorNames","parseForExpression","items","evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement","currentEl","forEach","item","iterationScopeVariables","getIterationScopeVariables","currentKey","generateKeyForIteration","nextEl","lookAheadForMatchingKeyedElementAndMoveItIfFound","__jmb_for_key","__jmb_for","updateElements","addElementInLoopAfterCurrentEl","initializeElements","removeAnyLeftOverElementsFromPreviousUpdate","forIteratorRE","inMatch","String","res","iteratorMatch","collection","scopeVariables","bindKeyAttribute","ifAttribute","clone","importNode","parentElement","insertBefore","undefined","tmpNextEl","nextElementFromOldLoop","nextElementFromOldLoopImmutable","nextSibling","handleAttributeBindingDirective","attrType","Alpine","ignoreFocusedForValueBinding","activeElement","isSameNode","checked","val","updateSelect","setAttribute","classNames","className","newClasses","removeAttribute","setIfChanged","getAttribute","arrayWrappedValue","options","option","selected","text","handleTextDirective","output","textContent","handleHtmlDirective","innerHTML","handleShowDirective","display","__jmb_is_shown","length","removeProperty","handle","showDirectiveLastElement","contains","executeAndClearRemainingShowDirectiveStack","showDirectiveStack","push","handleIfDirective","expressionResult","elementHasAlreadyBeenAdded","__jmb_inserted_me","registerListener","event","mutated","passive","handler","listenerTarget","target","offsetWidth","offsetHeight","runListenerHandler","removeEventListener","window","body","isKeyEvent","isListeningForASpecificKeyThatHasntBeenPressed","preventDefault","stopPropagation","detail","then","$jmb","callsCommands","executeCommands","nextModifier","delayModifier","m","delayId","slice","delayTime","endsWith","parseInt","substr","comp","timerId","unnamedTimers","Date","getTime","originalComponentNamedTimers","nextTickStack","CustomEvent","namedTimers","id","__jmb_listeners","self","evaluateCommandExpression","keyModifiers","debounceIndex","splice","keyToModifier","systemKeyModifiers","selectedSystemKeyModifiers","modifier","activelyPressedKeyModifiers","registerModelListener","listenerExpression","rightSideOfExpression","generateModelAssignmentFunction","hasAttribute","currentValue","newValue","safeParseNumber","multiple","selectedOptions","number","parseFloat","create","ObjectCreate","defineProperty","ObjectDefineProperty","isExtensible","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","preventExtensions","hasOwnProperty","ArrayPush","ArrayConcat","prototype","OtS","toString","obj","isUndefined","isFunction","proxyToValueMap","WeakMap","registerProxy","proxy","set","unwrap","replicaOrAny","get","BaseProxyHandler","membrane","originalTarget","wrapDescriptor","descriptor","wrapValue","originalSet","originalGet","wrapGetter","wrapSetter","copyDescriptorIntoShadowTarget","shadowTarget","originalDescriptor","wrappedDesc","lockShadowTarget","tagPropertyKey","thisArg","argArray","construct","newTarget","valueObserved","has","ownKeys","desc","writable","configurable","enumerable","getterMap$1","setterMap$1","reverseGetterMap","reverseSetterMap","ReactiveProxyHandler","getProxy","wrappedGetter","wrappedSetter","v","unwrapDescriptor","unwrapGetter","unwrapSetter","redGet","reverseGetter","redSet","reverseSetter","valueMutated","deleteProperty","setPrototypeOf","getterMap","setterMap","ReadOnlyHandler","getReadOnlyProxy","extract","objectOrArray","original","names","reduce","seed","formatter","header","plainOrProxy","object","hasBody","getGlobal","globalThis","global","init","ReferenceError","ObjectDotPrototype","defaultValueIsObservable","proto","defaultValueObserved","defaultValueMutated","defaultValueDistortion","createShadowTarget","ReactiveMembrane","valueDistortion","valueIsObservable","readOnlyObjectGraph","reactiveObjectGraph","unwrappedValue","distorted","getReactiveHandler","getReadOnlyHandler","unwrapProxy","p","distortedValue","Proxy","wrap","data","mutationCallback","ObservableMembrane","observable","unwrappedData","copy","cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","runClearTimeout","marker","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","len","run","Item","noop","nextTick","title","env","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","JMB","jembeClient","execName","actionName","params","kwargs","addCallCommand","stateName","FileList","File","addFilesForUpload","addInitialiseCommand","eventName","to","addEmitCommand","relativeExecName","mergeExistingParams","componentNames","startWith","equalSoFar","execNameSplit","thisExecNameSplit","component_reset","disableInputs","componentsOnPage","components","c","Component","$el","mounted","state","actions","mutationObserver","mount","originalComponent","$updateDom","JSON","parse","stringify","localAttr","localExpression","initAttr","initExpression","updateAttr","updateExpression","dataExtras","unobservedData","$local","getUnobservedData","actionEnabled","wrapDataInObservable","initReturnedCallback","$refs","getRefsProxy","$context","$nextTick","watchers","$watch","property","pauseReactivity","listenForNewElementsToInitialize","unmount","timerName","timerInfo","disconnect","findTargetPathInData","tree","level","is","treeIsArray","subpath","updateDom","path","fullDotNotationKey","dotNotationParts","comparisonData","part","walkAndSkipNestedComponents","initializeComponentCallback","__jmb","rootEl","initializeElement","executeAndClearNextTickStack","ltarget","__jmb_scope","registerListeners","resolveBoundAttributes","updateElement","shift","reverse","promiseChain","promise","finishElement","extVars","self_el","$self","$dispatch","getDispatchFunction","$scope","getScopeVars","dispatchEvent","bubbles","targetNode","observer","MutationObserver","mutations","closestParentComponent","closest","attributeName","addedNodes","nodeType","observe","childList","subtree","ref","scope_el","cs","jc","ComponentAPI","componentRef","dom","originalComponentRef","api","elIsNewComponent","walkComponentDom","callbackOnNewComponent","myExecName","componentExecName","deepCopy","inObject","outObject","getCookie","cookieValue","cookie","cookies","substring","decodeURIComponent","DOCUMENT_FRAGMENT_NODE","morphAttrs","fromNode","toNode","toNodeAttrs","attrNamespaceURI","attrValue","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","range","NS_XHTML","doc","HAS_TEMPLATE_SUPPORT","createElement","HAS_RANGE_SUPPORT","createRange","createFragmentFromTemplate","str","template","childNodes","createFragmentFromRange","fragment","selectNode","createContextualFragment","createFragmentFromWrap","toElement","compareNodeNames","fromEl","toEl","fromNodeName","fromCodeStart","toCodeStart","nodeName","toNodeName","charCodeAt","createElementNS","moveChildren","curChild","firstChild","nextChild","appendChild","syncBooleanAttrProp","OPTION","parentNode","parentName","selectedIndex","INPUT","TEXTAREA","oldValue","nodeValue","placeholder","SELECT","optgroup","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","defaultGetNodeKey","morphdomFactory","toNodeHtml","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","childrenOnly","fromNodesLookup","keyedRemovalList","addKeyedRemoval","removeNode","skipKeyedNodes","removeChild","walkDiscardedChildNodes","handleNodeAdded","unmatchedFromEl","replaceChild","morphEl","toElKey","morphChildren","curToNodeChild","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curFromNodeChild","outer","curFromNodeType","isCompatible","isEqualNode","nodeToBeAdded","cloneNode","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","specialElHandlers","indexTree","morphedNode","morphedNodeType","toNodeType","elToRemove","morphdom","ComponentRef","onDocument","hierarchyLevel","isPageComponent","url","changesUrl","_cleanDom","placeHolders","permanentPlaceHolders","_getPlaceHolders","_add_support_for_jmb_changed_attr_to_inputs","toJsonRequest","merge","parentComponent","replaceWith","documentElement","_morphdom","placeholderEl","newPlaceholder","insertAdjacentElement","Node","removes","querySelectorAll","rnode","domString","domParser","parseFromString","div","inputEl","_jmb_input_changed_attr_listener","UploadedFile","paramName","fileUploadId","files","multipleFiles","addToFormData","formData","file","append","JembeClient","getComponentsFromDocument","updateLocation","commands","filesForUpload","DOMParser","xRequestUrl","xRequestsInProgress","xRequestActiveElement","xRequestDisabledElements","disableInputBeforeRequestTimeoutId","onpopstate","onHistoryPopState","xRequestHeadersGenerators","componentsNodes","componentNode","eval","getComponentsAndGlobalsFromXResponse","xJembeResponse","globals","removeComponents","callWindowOpen","xComp","updateDocument","currentComponents","compRef","pageExecNames","pageExecName","pen","processingExecNames","newComponents","currentComponent","orignalComponent","placeHolderName","permanentPlaceHolderName","removedComponents","pop","childExecName","rmExecName","open","initParams","exisitingInitCommands","x","existingCmd","paramValue","_updateParam","_updateParamR","paramNames","pName","exisitingCallIndex","findIndex","existingFileId","uf","fileId","Math","random","initCommandIndex","cmd","getXUploadRequestFormData","fd","FormData","getXRequestJson","addComponents","setXRequestUrl","executeUpload","uploadFormData","headers","calculateXRequestHeaders","fetch","method","cache","credentials","redirect","referrer","response","ok","dispatchUpdatePageErrorEvent","log","json","ufiles","fu","fileUploadResponseId","location","href","dispatchStartUpdatePageEvent","requestBody","enableInputsAfterResponse","info","componentsAndGlobals","dispatchUpdatePageEvent","message","topComponent","historyState","history","replaceState","pushState","execNames","en","domNode","isXUpdate","inputsDisabled","fromEntries","disableInputsBeforeRequest","networkError","disabled","readOnly","f","focus","addXRequestHeaderGenerator","headerGenCallback","walkComponent","querySelector","walkDocument"],"mappings":";AAohBC,aAjhBM,SAASA,IACL,OAAA,IAAIC,QAAQC,IACY,WAAvBC,SAASC,WACTD,SAASE,iBAAiB,mBAAoBH,GAE9CA,MAKL,SAASI,EAAYC,GACjBC,OAAAA,MAAMC,KAAK,IAAIC,IAAIH,IAGvB,SAASI,IACLC,OAAAA,UAAUC,UAAWD,UAAUC,UAAUC,SAAS,YAClDF,UAAUC,UAAUC,SAAS,SAGjC,SAASC,EAAwBC,EAAQC,GACrCD,OAAAA,GAAUC,EAGd,SAASC,EAAwBC,EAAIC,GACP,aAA7BD,EAAGE,QAAQC,cACXC,QAAQC,iBAAiBJ,gGAAwGA,KACzF,IAAjCD,EAAGM,QAAQC,mBAClBH,QAAQC,qCAAqCJ,+GAI9C,SAASO,EAAUC,GACfA,OAAAA,EAAQC,QAAQ,kBAAmB,SAASA,QAAQ,QAAS,KAAKP,cAGtE,SAASQ,EAAUF,GACfA,OAAAA,EAAQN,cAAcO,QAAQ,SAAU,CAACE,EAAOC,IAASA,EAAKC,eAGlE,SAASC,EAAKf,EAAIgB,GACjBA,IAAiB,IAAjBA,EAAShB,GAAe,OAExBiB,IAAAA,EAAOjB,EAAGkB,kBAEPD,KAAAA,GACHF,EAAKE,EAAMD,GAEXC,EAAOA,EAAKE,mBAIb,SAASC,EAASC,EAAMC,GACvBC,IAAAA,EACG,OAAA,WACCC,IAAAA,EAAU,KAAMC,EAAOC,UAK3BC,aAAaJ,GACbA,EAAUK,WALE,WACRL,EAAU,KACVF,EAAKQ,MAAML,EAASC,IAGIH,IAqdnC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,YAAA,EAAA,QAAA,UAAA,EAAA,QAAA,wBAAA,EAAA,QAAA,wBAAA,EAAA,QAAA,UAAA,EAAA,QAAA,UAAA,EAAA,QAAA,KAAA,EAAA,QAAA,SAAA,EAAA,QAAA,UAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,QAAA,EAAA,QAAA,UAAA,EAAA,QAAA,mBAAA,EAAA,QAAA,cAAA,EAAA,QAAA,oCAAA,EAAA,QAAA,0BAAA,EAAA,QAAA,aAAA,EAAA,QAAA,cAAA,EAAA,QAAA,mBAAA,EAAA,QAAA,oBAAA,EAAA,QAAA,iBAAA,EAAA,QAAA,oBAAA,EAAA,QAAA,qBAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,WAAA,EAAA,QAAA,UAAA,EAAA,QAAA,KAAA,EAAA,QAAA,qBAAA,QAAA,oBAAA,QAAA,wBAAA,EAjdD,MAAMQ,EAAc,CAAC9B,EAAI+B,EAAYC,KAG7B,GAFJ5B,QAAQC,sBAAsB2B,sBAA0BD,eAAyB/B,IAE3ER,IAEIwC,MADNC,OAAOC,OAAOF,EAAO,CAAEhC,GAAAA,EAAI+B,WAAAA,IACrBC,GAId,SAASG,EAASC,GAAI,GAAEpC,EAAF,WAAM+B,IACpB,IACMM,MAAAA,EAAQD,IACPC,OAAAA,aAAiBvD,QAClBuD,EAAMC,MAAOC,GAAMT,EAAY9B,EAAI+B,EAAYQ,IAC/CF,EACR,MAAOE,GACLT,EAAY9B,EAAI+B,EAAYQ,IAI7B,SAASC,EAAUxC,EAAI+B,EAAYU,EAAaC,EAA4B,IACxEP,OAAAA,EAAS,IACc,mBAAfJ,EACAA,EAAWY,KAAKF,GAGnB,IAAIG,SAAS,CAAC,WAAYX,OAAOY,KAAKH,4DAAqFX,8BAA3H,CACJU,KAAgBR,OAAOa,OAAOJ,IAEnC,CAAE1C,GAAAA,EAAI+B,WAAAA,IAGN,SAASgB,EAAkB/C,EAAI+B,EAAYU,EAAaC,EAA4B,IAChFP,OAAAA,EAAS,KACR,GAAsB,mBAAfJ,EACAjD,OAAAA,QAAQC,QAAQgD,EAAWY,KAAKF,EAAaC,EAAyB,SAG7EM,IAAAA,EAAgBJ,SAQhBX,GALAe,EAAgBf,OAAOgB,eAAe,oBAAoBC,YAK1DjB,OAAOY,KAAKJ,GAAa9C,SAASoC,GAAa,CAC3CoB,IAAAA,EAAmB,IAAIP,SAAS,CAAC,iBAAkBX,OAAOY,KAAKH,kCAA2DX,MAAvG,CACnBU,KAAgBR,OAAOa,OAAOJ,IAG9B,MAA2B,mBAApBS,EACArE,QAAQC,QAAQoE,EAAgBR,KAAKF,EAAaC,EAAyB,SAE3E5D,QAAQC,UAIhBD,OAAAA,QAAQC,QAAS,IAAIiE,EAAc,CAAC,iBAAkBf,OAAOY,KAAKH,2BAAoDX,MAArG,CACpBU,KAAgBR,OAAOa,OAAOJ,MAEnC,CAAE1C,GAAAA,EAAI+B,WAAAA,IAGb,MAAMqB,EAAU,sFAET,SAASC,EAAQC,GACdC,MAAAA,EAAOC,EAAoCF,EAAKC,MAE/CH,OAAAA,EAAQK,KAAKF,GAGjB,SAASG,EAAU1D,EAAI2D,EAAWC,GACjCC,IAAAA,EAAaxE,MAAMC,KAAKU,EAAG8D,YAAYC,OAAOV,GAASW,IAAIC,GAG3DC,EAAkBL,EAAWE,OAAO9D,GAAgC,WAAnBA,EAAU2D,MAAmB,GAE9EM,GAAAA,EAAiB,CACbC,IAAAA,EAAe3B,EAAUxC,EAAIkE,EAAgBnC,WAAY4B,EAAUS,OAGvEP,EAAaA,EAAWQ,OAAOpC,OAAOqC,QAAQH,GAAcH,IAAI,EAAET,EAAMlB,KAAW4B,EAAmB,CAAEV,KAAAA,EAAMlB,MAAAA,MAG9GuB,OAAAA,EAAaC,EAAWE,OAAOQ,GAAKA,EAAEX,OAASA,GAE5CY,EAAeX,GAG1B,SAASW,EAAeX,GAChBY,IAAAA,EAAiB,CAAC,OAAQ,QAAS,OAAQ,aAExCZ,OAAAA,EAAWa,KAAK,CAACC,EAAGC,KACnBC,IAAAA,GAA4C,IAApCJ,EAAeK,QAAQH,EAAEf,MAAe,YAAce,EAAEf,KAChEmB,GAA4C,IAApCN,EAAeK,QAAQF,EAAEhB,MAAe,YAAcgB,EAAEhB,KAE7Da,OAAAA,EAAeK,QAAQD,GAASJ,EAAeK,QAAQC,KAI/D,SAASd,GAAmB,KAAEV,EAAF,MAAQlB,IACjC2C,MAAAA,EAAiBxB,EAAoCD,GAErD0B,EAAYD,EAAepE,MAAMwC,GACjC8B,EAAaF,EAAepE,MAAM,sBAClCuE,EAAYH,EAAepE,MAAM,0BAA4B,GAE5D,MAAA,CACHgD,KAAMqB,EAAYA,EAAU,GAAK,KACjC5C,MAAO6C,EAAaA,EAAW,GAAK,KACpCC,UAAWA,EAAUnB,IAAIO,GAAKA,EAAE7D,QAAQ,IAAK,KAC7CqB,WAAYM,GAIb,SAAS+C,EAAcC,GAWnBC,MARmB,CACtB,WAAW,UAAU,WAAW,WAAW,SAAS,OAAQ,WAC5D,YAAa,YAAa,WAAY,aAAa,kBACnD,sBAAuB,iBAAkB,WAAY,WAAY,OACjE,QAAS,cAAe,UAAW,QAAS,WAAY,QAAS,QACjE,YAGqB3F,SAAS0F,GAG/B,SAAS7B,EAAoCD,GAC5CA,OAAAA,EAAKgC,WAAW,KACThC,EAAK7C,QAAQ,IAAK,WAClB6C,EAAKgC,WAAW,KAChBhC,EAAK7C,QAAQ,IAAK,aAGtB6C,EAGJ,SAASiC,EAA0BC,EAAWC,EAAWC,SACrDF,OAAAA,EAAUG,MAAM,KAAK7B,OAAO2B,GAGhC,MAAMG,EAAqB,KAiUjC,QAAA,mBAAA,EAhUM,MAAMC,EAAsB,MAgUlC,QAAA,oBAAA,EA/TM,MAAMC,EAAuB,YAE7B,SAASC,EAAahG,EAAIiG,EAAMC,EAAQvC,EAAWwC,GAAY,GAE9DA,GAAAA,EAAW,OAAOF,IAElBjG,GAAAA,EAAGoG,kBAAoBpG,EAAGoG,iBAAiBxC,OAASiC,EAGpD,OAGEQ,MAAAA,EAAQ3C,EAAU1D,EAAI2D,EAAW,cACjC2C,EAAW5C,EAAU1D,EAAI2D,EAAW,QAAQ,GAG9C2C,GAAAA,GAAYA,EAASnB,UAAUxF,SAAS,cAAe,CACnDwF,IAAAA,EAAYmB,EAASnB,UAGrBA,GAAAA,EAAUxF,SAAS,SAAYwF,EAAUxF,SAAS,MAAO,OAAOsG,IAE9DM,MAAAA,EAA+BpB,EAAUxF,SAAS,OAASwF,EAAUxF,SAAS,OAMpF6G,EAAmBxG,EAHnBmF,EAAYoB,EACNpB,EAAUpB,OAAO,CAACQ,EAAGkC,IAAUA,EAAQtB,EAAUL,QAAQ,QAAUK,EAEvCc,EAAMC,QAEjCG,EAAMK,KAAKpD,GAAQ,CAAC,QAAS,cAAe,aAAa3D,SAAS2D,EAAKjB,QAC9EsE,EAAoB3G,EAAI2D,EAAW0C,EAAOJ,EAAMC,GAGhDD,IAID,SAASW,EAAc5G,EAAI6G,EAAMX,EAAQvC,EAAWwC,GAAY,GAE/DA,GAAAA,EAAW,OAAOU,IAElB7G,GAAAA,EAAGoG,kBAAoBpG,EAAGoG,iBAAiBxC,OAASkC,EAGpD,OAGEO,MAAAA,EAAQ3C,EAAU1D,EAAI2D,EAAW,cACjC2C,EAAW5C,EAAU1D,EAAI2D,EAAW,QAAQ,GAE9C2C,GAAAA,GAAYA,EAASnB,UAAUxF,SAAS,cAAe,CACnDwF,IAAAA,EAAYmB,EAASnB,UAErBA,GAAAA,EAAUxF,SAAS,QAAWwF,EAAUxF,SAAS,OAAQ,OAAOkH,IAE9DN,MAAAA,EAA+BpB,EAAUxF,SAAS,OAASwF,EAAUxF,SAAS,OAKpFmH,EAAoB9G,EAHpBmF,EAAYoB,EACNpB,EAAUpB,OAAO,CAACQ,EAAGkC,IAAUA,EAAQtB,EAAUL,QAAQ,QAAUK,EAEtCoB,EAA8BM,EAAMX,QAChEG,EAAMK,KAAKpD,GAAQ,CAAC,QAAS,cAAe,aAAa3D,SAAS2D,EAAKjB,QAC9E0E,EAAqB/G,EAAI2D,EAAW0C,EAAOQ,EAAMX,GAEjDW,IAID,SAASL,EAAmBxG,EAAImF,EAAW6B,EAAcd,GAe5De,EAAiBjH,EAAImF,EAAW6B,EAAc,OAAUd,EAbpC,CAChBgB,SAAUC,EAAchC,EAAW,WAAY,KAC/CiC,OAAQD,EAAchC,EAAW,SAAU,UAC3CkC,MAAO,CACHC,QAAS,EACTC,MAAOJ,EAAchC,EAAW,QAAS,KAE7CqC,OAAQ,CACJF,QAAS,EACTC,MAAO,MAI8D1B,GAG1E,SAASiB,EAAoB9G,EAAImF,EAAWoB,EAA8BkB,EAAcvB,GAqB3Fe,EAAiBjH,EAAImF,EAAW,OAAUsC,EAAcvB,EAbpC,CAChBgB,SALaX,EACXY,EAAchC,EAAW,WAAY,KACrCgC,EAAchC,EAAW,WAAY,KAAO,EAI9CiC,OAAQD,EAAchC,EAAW,SAAU,UAC3CkC,MAAO,CACHC,QAAS,EACTC,MAAO,KAEXC,OAAQ,CACJF,QAAS,EACTC,MAAOJ,EAAchC,EAAW,QAAS,MAI4BW,GAGjF,SAASqB,EAAchC,EAAWuC,EAAKC,GAE/BxC,IAA4B,IAA5BA,EAAUL,QAAQ4C,GAAa,OAAOC,EAGpCC,MAAAA,EAAWzC,EAAUA,EAAUL,QAAQ4C,GAAO,GAEhD,IAAEE,EAAU,OAAOD,EAEnBD,GAAQ,UAARA,IAIMG,EAAUD,GAAW,OAAOD,EAGlCD,GAAQ,aAARA,EAAoB,CAEhB9G,IAAAA,EAAQgH,EAAShH,MAAM,cACvBA,GAAAA,EAAO,OAAOA,EAAM,GAGxB8G,MAAQ,WAARA,GAEI,CAAC,MAAO,QAAS,OAAQ,SAAU,UAAU/H,SAASwF,EAAUA,EAAUL,QAAQ4C,GAAO,IAClF,CAACE,EAAUzC,EAAUA,EAAUL,QAAQ4C,GAAO,IAAII,KAAK,KAI/DF,EAGJ,SAASX,EAAiBjH,EAAImF,EAAW4C,EAAOC,EAAO9B,EAAQ+B,EAAarE,GAE3E5D,EAAGoG,kBACHpG,EAAGoG,iBAAiB8B,QAAUlI,EAAGoG,iBAAiB8B,SAIhDC,MAAAA,EAAenI,EAAGoI,MAAMd,QACxBe,EAAiBrI,EAAGoI,MAAME,UAC1BC,EAAuBvI,EAAGoI,MAAMI,gBAGhCC,GAAgBtD,EAAUxF,SAAS,aAAgBwF,EAAUxF,SAAS,SACtE+I,EAAoBD,GAAetD,EAAUxF,SAAS,WACtDgJ,EAAkBF,GAAetD,EAAUxF,SAAS,SAKpDiJ,EAAS,CACXC,QACQH,IAAmB1I,EAAGoI,MAAMd,QAAUW,EAAYZ,MAAMC,SACxDqB,IAAiB3I,EAAGoI,MAAME,mBAAqBL,EAAYZ,MAAME,MAAQ,SAEjFuB,SACQH,IAAiB3I,EAAGoI,MAAMI,gBAAkBP,EAAYb,QAC5DpH,EAAGoI,MAAMW,mBAAqB,CAAEL,EAAqB,UAAY,GAAKC,EAAmB,YAAc,IAAIb,KAAK,KAAKkB,OACrHhJ,EAAGoI,MAAMa,sBAAwBhB,EAAYf,SAAW,OACxDlH,EAAGoI,MAAMc,yBAA4B,kCAEzCjD,OACI8B,KAEJoB,MACQT,IAAmB1I,EAAGoI,MAAMd,QAAUW,EAAYT,OAAOF,SACzDqB,IAAiB3I,EAAGoI,MAAME,mBAAqBL,EAAYT,OAAOD,MAAQ,SAElFV,OACImB,KAEJoB,UACQV,IAAmB1I,EAAGoI,MAAMd,QAAUa,GACtCQ,IAAiB3I,EAAGoI,MAAME,UAAYD,GACtCM,IAAiB3I,EAAGoI,MAAMI,gBAAkBD,GAChDvI,EAAGoI,MAAMW,mBAAqB,KAC9B/I,EAAGoI,MAAMa,mBAAqB,KAC9BjJ,EAAGoI,MAAMc,yBAA2B,OAI5CG,EAAWrJ,EAAI4I,EAAQhF,EAAMsC,GA8HhC,QAAA,qBAAA,EA3HD,MAAMoD,EAAyB,CAACvH,EAAY/B,EAAI2D,IACf,mBAAf5B,EACR4B,EAAU4F,yBAAyBvJ,EAAI+B,GACvCA,EAGH,SAAS4E,EAAoB3G,EAAI2D,EAAWE,EAAYmD,EAAcd,GAKzEsD,EAAkBxJ,EAJJwF,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,UAAZA,EAAElC,QAAsB,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAC9H6B,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,gBAAZA,EAAElC,QAA4B,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAC3I6B,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,cAAZA,EAAElC,QAA0B,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAErGqD,EAAc,OAAUnB,EAAoBK,GAG5F,SAASa,EAAqB/G,EAAI2D,EAAWE,EAAY4D,EAAcvB,GAK1EsD,EAAkBxJ,EAJJwF,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,UAAZA,EAAElC,QAAsB,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAC9H6B,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,gBAAZA,EAAElC,QAA4B,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAC3I6B,EAA0B8D,GAAwBzF,EAAW4F,KAAKlF,GAAiB,cAAZA,EAAElC,QAA0B,CAAEN,WAAY,KAAMA,WAAY/B,EAAI2D,IAErG,OAAU8D,EAAc3B,EAAqBI,GAG7F,SAASsD,EAAkBxJ,EAAI0J,EAAeC,EAAcC,EAAY7B,EAAOC,EAAOpE,EAAMsC,GAE3FlG,EAAGoG,kBACHpG,EAAGoG,iBAAiB8B,QAAUlI,EAAGoG,iBAAiB8B,SAGhD2B,MAAAA,EAAkB7J,EAAG8J,wBAA0B,GAE/ClB,EAAS,CACXC,QACI7I,EAAGyF,UAAUsE,OAAOJ,IAExBb,SACI9I,EAAGyF,UAAUsE,OAAOL,IAExBzD,OACI8B,KAEJoB,MAEInJ,EAAGyF,UAAUuE,UAAUL,EAAa5F,OAAOQ,IAAMsF,EAAgBlK,SAAS4E,KAC1EvE,EAAGyF,UAAUsE,OAAOH,IAExB/C,OACImB,KAEJoB,UACIpJ,EAAGyF,UAAUuE,UAAUN,EAAc3F,OAAOQ,IAAMsF,EAAgBlK,SAAS4E,KAC3EvE,EAAGyF,UAAUuE,UAAUJ,EAAW7F,OAAOQ,IAAMsF,EAAgBlK,SAAS4E,OAIhF8E,EAAWrJ,EAAI4I,EAAQhF,EAAMsC,GAG1B,SAASmD,EAAWrJ,EAAI4I,EAAQhF,EAAMsC,GACnC+D,MAAAA,EAASC,EAAK,KAChBtB,EAAO/B,OAIH7G,EAAGmK,aACHvB,EAAOQ,iBAGJpJ,EAAGoG,mBAGdpG,EAAGoG,iBAAmB,CAEnBxC,KAAMA,EAILsE,OAAQgC,EAAK,KACThE,EAAOH,GAEPkE,MAEJA,OAAAA,EAEAG,UAAW,MAGfxB,EAAOC,QACPD,EAAOE,SAEP9I,EAAGoG,iBAAiBgE,UAAYC,sBAAsB,KAG9CnD,IAAAA,EAAiG,IAAtFoD,OAAOC,iBAAiBvK,GAAIiJ,mBAAmBvI,QAAQ,MAAO,IAAIA,QAAQ,IAAK,KAE7E,IAAbwG,IACAA,EAA6E,IAAlEoD,OAAOC,iBAAiBvK,GAAIwK,kBAAkB9J,QAAQ,IAAK,MAG1EkI,EAAO3C,OAEPjG,EAAGoG,iBAAiBgE,UAAYC,sBAAsB,KAClDzB,EAAOO,MAEPvH,WAAW5B,EAAGoG,iBAAiB6D,OAAQ/C,OAK5C,SAASW,EAAUpH,GACf,OAAEpB,MAAMoL,QAAQhK,KAAciK,MAAMjK,GAKxC,SAASyJ,EAAKlJ,GACb2J,IAAAA,GAAS,EAEN,OAAA,WACGA,IACFA,GAAS,EACT3J,EAASa,MAAM,KAAMH;;AChYhC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,mBAAA,EAjJD,IAAA,EAAA,QAAA,YAEO,SAASkJ,EAAmBjH,EAAWkH,EAAY9I,EAAY+I,EAAeC,IACzDF,EAAAA,EAAAA,yBAAAA,EAAY,WAEhCG,IAAAA,EACEC,EADoC,mBAAflJ,EACF4B,EAAU4F,yBAAyBsB,EAAY9I,GAC/CA,GAErBmJ,EAAQC,EAA2DxH,EAAWkH,EAAYG,EAAeD,GAGzGK,EAAYP,EAChBK,EAAMG,QAAQ,CAACC,EAAM7E,KACb8E,IAAAA,EAA0BC,EAA2BR,EAAeM,EAAM7E,EAAOyE,EAAOH,KACxFU,EAAaC,EAAwB/H,EAAWkH,EAAYpE,EAAO8E,GACnEI,EAASC,EAAiDR,EAAUjK,mBAAoBsK,GAGtFE,UAWKA,EAAOE,cAEdF,EAAOG,UAAYP,EACnB5H,EAAUoI,eAAeJ,EAAQ,IAAMA,EAAOG,aAb9CH,EAASK,EAA+BnB,EAAYO,IAGvCO,EAAAA,EAAAA,cAAAA,EAAQ,OAAU,OAAUhI,EAAWmH,GAEpDa,EAAOG,UAAYP,EACnB5H,EAAUsI,mBAAmBN,EAAQ,IAAMA,EAAOG,aAUtDV,EAAYO,GACFE,cAAgBJ,IAG9BS,EAA4Cd,EAAWzH,GAI3D,SAASsH,EAAmBlJ,GACpBoK,IAAAA,EAAgB,iCAGhBC,EAAUC,OAAOtK,GAAYnB,MADhB,sCAEb,IAAEwL,EAAS,OACXE,IAAAA,EAAM,GACVA,EAAIpB,MAAQkB,EAAQ,GAAGpD,OACnBsC,IAAAA,EAAOc,EAAQ,GAAGpD,OAAOtI,QANT,WAMgC,IAChD6L,EAAgBjB,EAAK1K,MAAMuL,GAYxBG,OAVHC,GACAD,EAAIhB,KAAOA,EAAK5K,QAAQyL,EAAe,IAAInD,OAC3CsD,EAAI7F,MAAQ8F,EAAc,GAAGvD,OAEzBuD,EAAc,KACdD,EAAIE,WAAaD,EAAc,GAAGvD,SAGtCsD,EAAIhB,KAAOA,EAERgB,EAGX,SAASd,EAA2BR,EAAeM,EAAM7E,EAAOyE,EAAOH,GAE/D0B,IAAAA,EAAiB1B,EAAY,IAAIA,GAAa,GAK3C0B,OAJPA,EAAezB,EAAcM,MAAQA,EACjCN,EAAcvE,QAAOgG,EAAezB,EAAcvE,OAASA,GAC3DuE,EAAcwB,aAAYC,EAAezB,EAAcwB,YAActB,GAElEuB,EAGX,SAASf,EAAwB/H,EAAW3D,EAAIyG,EAAO8E,GAC/CmB,IAAAA,GAAmB,EAAU1M,EAAAA,WAAAA,EAAI2D,EAAW,QAAQI,OAAOT,GAAuB,QAAfA,EAAKjB,OAAiB,GAGzF,OAAEqK,EAEC/I,EAAU4F,yBAAyBvJ,EAAI0M,EAAiB3K,WAAY,IAAMwJ,GAFlD9E,EAKnC,SAAS0E,EAA2DxH,EAAW3D,EAAIgL,EAAeD,GAC1F4B,IAAAA,GAAc,EAAU3M,EAAAA,WAAAA,EAAI2D,EAAW,MAAM,GAE7CgJ,GAAAA,IAAiBhJ,EAAU4F,yBAAyBvJ,EAAI2M,EAAY5K,YAC7D,MAAA,GAGPmJ,IAAAA,EAAQvH,EAAU4F,yBAAyBvJ,EAAIgL,EAAcE,MAAOH,GAOjEG,OAJH,EAAUA,EAAAA,WAAAA,IAAUA,GAAS,IAC7BA,EAAQ7L,MAAMC,KAAKD,MAAM6L,GAAOrI,OAAQ0B,GAAKA,EAAI,IAG9C2G,EAGX,SAASc,EAA+BnB,EAAYO,GAC5CwB,IAAAA,EAAQ5N,SAAS6N,WAAWhC,EAAWvK,SAAS,GAI7C8K,OAFPA,EAAU0B,cAAcC,aAAaH,EAAOxB,EAAUjK,oBAE/CiK,EAAUjK,mBAGrB,SAASyK,EAAiDD,EAAQF,GAC1D,IAAEE,EAAQ,OAGVA,QAAyBqB,IAAzBrB,EAAOE,cAA6B,OAGpCF,GAAAA,EAAOE,gBAAkBJ,EAAY,OAAOE,EAI5CsB,IAAAA,EAAYtB,EAEVsB,KAAAA,GAAW,CACTA,GAAAA,EAAUpB,gBAAkBJ,EACrBwB,OAAAA,EAAUH,cAAcC,aAAaE,EAAWtB,GAG3DsB,KAAaA,EAAU9L,yBAAqE6L,IAA/CC,EAAU9L,mBAAmB0K,gBAA+BoB,EAAU9L,oBAI3H,SAAS+K,EAA4Cd,EAAWzH,GAGrDuJ,IAFHA,IAAAA,KAA0B9B,EAAUjK,yBAAqE6L,IAA/C5B,EAAUjK,mBAAmB0K,gBAA+BT,EAAUjK,mBAE7H+L,GAAwB,CACvBC,IAAAA,EAAkCD,EAClCE,EAAcF,EAAuB/L,oBAC3B+L,EAAAA,EAAAA,eAAAA,EAAwB,KAClCC,EAAgCnD,UACjC,OAAUrG,GACbuJ,KAA0BE,QAA6CJ,IAA9BI,EAAYvB,gBAA+BuB;;ACpD3F,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,gCAAA,EA3FD,IAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,aA0FC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAxFM,SAASC,EAAgC1J,EAAW3D,EAAIqF,EAAUtD,EAAYgJ,EAAWuC,EAAUnI,GAClG9C,IAAAA,EAAQsB,EAAU4F,yBAAyBvJ,EAAI+B,EAAYgJ,GAE3D1F,GAAa,UAAbA,EAAsB,CAClBkI,GAAAA,EAAOC,QAAAA,8BAAgCxO,SAASyO,cAAcC,WAAW1N,GAAK,OAO9EA,QAJUgN,IAAV3K,GAAuBgK,OAAOtK,GAAYnB,MAAM,QAChDyB,EAAQ,IAGI,UAAZrC,EAAG4D,UAIyBoJ,IAAxBhN,EAAG8D,WAAWzB,OAAoC,SAAbiL,EACrCtN,EAAGqC,MAAQA,EACS,SAAbiL,IACPtN,EAAG2N,SAAU,EAAwB3N,EAAAA,yBAAAA,EAAGqC,MAAOA,SAEhD,GAAgB,aAAZrC,EAAG4D,KAIW,kBAAVvB,GAAyB,CAAC,UAAM2K,GAAWrN,SAAS0C,IAAuB,SAAbiL,EAEjD,SAAbA,IACHjO,MAAMoL,QAAQpI,GAIdrC,EAAG2N,QAAUtL,EAAMqE,KAAKkH,IAAO,EAAwBA,EAAAA,yBAAAA,EAAK5N,EAAGqC,QAE/DrC,EAAG2N,UAAYtL,GARnBrC,EAAGqC,MAAQgK,OAAOhK,QAWnB,GAAmB,WAAfrC,EAAGE,QACV2N,EAAa7N,EAAIqC,OACd,CACCrC,GAAAA,EAAGqC,QAAUA,EAAO,OAExBrC,EAAGqC,MAAQA,QAEZ,GAAiB,UAAbgD,EACHhG,GAAAA,MAAMoL,QAAQpI,GAAQ,CAChBwH,MAAAA,EAAkB7J,EAAG8J,wBAA0B,GACrD9J,EAAG8N,aAAa,SAAS,EAAYjE,EAAAA,aAAAA,EAAgBxF,OAAOhC,IAAQyF,KAAK,WACtE,GAAqB,iBAAVzF,EAAoB,CAGDJ,OAAOY,KAAKR,GAAOqC,KAAK,CAACC,EAAGC,IAAMvC,EAAMsC,GAAKtC,EAAMuC,IAE3DyG,QAAQ0C,IACzB1L,EAAM0L,IACoBA,EAAAA,EAAAA,2BAAAA,GAAY1C,QAAQ2C,GAAahO,EAAGyF,UAAUsE,IAAIiE,KAElDD,EAAAA,EAAAA,2BAAAA,GAAY1C,QAAQ2C,GAAahO,EAAGyF,UAAUuE,OAAOgE,UAGpF,CACGnE,MAAAA,EAAkB7J,EAAG8J,wBAA0B,GAC/CmE,EAAa5L,GAAQ,EAA0BA,EAAAA,2BAAAA,GAAS,GAC9DrC,EAAG8N,aAAa,SAAS,EAAYjE,EAAAA,aAAAA,EAAgBxF,OAAO4J,IAAanG,KAAK,WAGlFzC,EAAWF,EAAUxF,SAAS,UAAW,EAAU0F,EAAAA,WAAAA,GAAYA,EAG3D,CAAC,UAAM2H,GAAW,GAAOrN,SAAS0C,GAClCrC,EAAGkO,gBAAgB7I,IAELA,EAAAA,EAAAA,eAAAA,GAAY8I,EAAanO,EAAIqF,EAAUA,GAAY8I,EAAanO,EAAIqF,EAAUhD,GAKxG,SAAS8L,EAAanO,EAAIqF,EAAUhD,GAC5BrC,EAAGoO,aAAa/I,IAAahD,GAC7BrC,EAAG8N,aAAazI,EAAUhD,GAIlC,SAASwL,EAAa7N,EAAIqC,GAChBgM,MAAAA,EAAoB,GAAGhK,OAAOhC,GAAO2B,IAAI3B,GAAkBA,EAAQ,IAEzEhD,MAAMC,KAAKU,EAAGsO,SAASjD,QAAQkD,IAC3BA,EAAOC,SAAWH,EAAkB1O,SAAS4O,EAAOlM,OAASkM,EAAOE;;AClF3E,aAPM,SAASC,EAAoB1O,EAAI2O,EAAQ5M,QAE7BiL,IAAX2B,GAAwBtC,OAAOtK,GAAYnB,MAAM,QACjD+N,EAAS,IAGb3O,EAAG4O,YAAcD,EACpB,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA;;ACLA,aAFM,SAASE,EAAoBlL,EAAW3D,EAAI+B,EAAYgJ,GAC3D/K,EAAG8O,UAAYnL,EAAU4F,yBAAyBvJ,EAAI+B,EAAYgJ,GACrE,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA;;ACkEA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA,EApED,IAAA,EAAA,QAAA,YAEO,SAASgE,EAAoBpL,EAAW3D,EAAIqC,EAAO8C,EAAW2F,GAAgB,GAC3EjE,MAAAA,EAAO,KACT7G,EAAGoI,MAAM4G,QAAU,OACnBhP,EAAGiP,gBAAiB,GAGlBhJ,EAAO,KACe,IAApBjG,EAAGoI,MAAM8G,QAAqC,SAArBlP,EAAGoI,MAAM4G,QAClChP,EAAGkO,gBAAgB,SAEnBlO,EAAGoI,MAAM+G,eAAe,WAG5BnP,EAAGiP,gBAAiB,GAGpBnE,IAAkB,IAAlBA,EAMA,YALIzI,EACA4D,IAEAY,KAKFuI,MAAAA,EAAS,CAACrQ,EAASmH,KACjB7D,IACyB,SAArBrC,EAAGoI,MAAM4G,SAAsBhP,EAAGoG,oBACrBpG,EAAAA,EAAAA,cAAAA,EAAI,KACbiG,KACDC,EAAQvC,GAEf5E,EAAQ,SAEiB,SAArBiB,EAAGoI,MAAM4G,SACKhP,EAAAA,EAAAA,eAAAA,EAAI,KACdjB,EAAQ,KACJ8H,OAELX,EAAQvC,GAEX5E,EAAQ,SAUhBoG,EAAUxF,SAAS,aACnByP,EAAOnF,GAAUA,IAAU,SAO3BtG,EAAU0L,2BAA8B1L,EAAU0L,yBAAyBC,SAAStP,IACpF2D,EAAU4L,6CAGd5L,EAAU6L,mBAAmBC,KAAKL,GAElCzL,EAAU0L,yBAA2BrP;;AC7CxC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,kBAAA,EAtBD,IAAA,EAAA,QAAA,YAEO,SAAS0P,EAAkB/L,EAAW3D,EAAI2P,EAAkB7E,EAAeC,IACtD/K,EAAAA,EAAAA,yBAAAA,EAAI,UAEtB4P,MAAAA,EAA6B5P,EAAGmB,qBAAkE,IAA5CnB,EAAGmB,mBAAmB0O,kBAE9EF,IAAAA,GAAuBC,IAA8B5P,EAAGoG,kBAU/CuJ,GAAoBC,IACf5P,EAAAA,EAAAA,eAAAA,EAAGmB,mBAAoB,KACjCnB,EAAGmB,mBAAmB6I,UACvB,OAAUrG,EAAWmH,OAbmD,CACrE8B,MAAAA,EAAQ5N,SAAS6N,WAAW7M,EAAGM,SAAS,GAE9CN,EAAG8M,cAAcC,aAAaH,EAAO5M,EAAGmB,qBAE3BnB,EAAAA,EAAAA,cAAAA,EAAGmB,mBAAoB,OAAU,OAAUwC,EAAWmH,GAEnEnH,EAAUsI,mBAAmBjM,EAAGmB,mBAAoB4J,GAEpD/K,EAAGmB,mBAAmB0O,mBAAoB;;ACuMjD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA,EAvND,IAAA,EAAA,QAAA,YAEO,SAASC,EAAiBnM,EAAW3D,EAAI+P,EAAO5K,EAAWpD,EAAYgJ,EAAY,SAAWiF,GAAQ,GACnG1B,MAAAA,EAAU,CACZ2B,QAAS9K,EAAUxF,SAAS,YAO5BuQ,IAAAA,EAASC,EA6EThL,GAjFAA,EAAUxF,SAAS,WACnBoQ,GAAQ,EAAUA,EAAAA,WAAAA,IAKlB5K,EAAUxF,SAAS,SACnBwQ,EAAiBnR,SAEjBkR,EAAU3N,CAAAA,IAEFvC,EAAGsP,SAAS/M,EAAE6N,SAGdpQ,EAAGqQ,YAAc,GAAKrQ,EAAGsQ,aAAe,IAI5CC,EAAmB5M,EAAW5B,EAAYQ,EAAGwI,EAAW/K,GAEpDmF,EAAUxF,SAAS,SACnBX,SAASwR,oBAAoBT,EAAOG,EAAS5B,QAIrD6B,EAAiBhL,EAAUxF,SAAS,UAC9B8Q,OAAUtL,EAAUxF,SAAS,YAAcX,SAAWgB,EAE5DkQ,EAAU3N,CAAAA,IAGF4N,IAAAA,IAAmBM,QAAUN,IAAmBnR,YAC3CA,SAAS0R,KAAKpB,SAAStP,GAExB,YADAmQ,EAAeK,oBAAoBT,EAAOG,EAAS5B,GAKvDqC,GAAAA,EAAWZ,IACPa,EAA+CrO,EAAG4C,GAClD,OAIJA,EAAUxF,SAAS,YAAY4C,EAAEsO,iBACjC1L,EAAUxF,SAAS,SAAS4C,EAAEuO,kBAK5BV,MAAAA,EAAoB,UAAX7N,EAAEqB,KAAkBrB,EAAEwO,OAAF,OAAqBxO,EAAE6N,OACtD,IAACjL,EAAUxF,SAAS,SAAWyQ,IAAWpQ,EAAI,CAC1BuQ,EAAmB5M,EAAW5B,EAAYQ,EAAGwI,EAAW/K,GAEhEgR,KAAK3O,KACC,IAAVA,EACAE,EAAEsO,iBAEE1L,EAAUxF,SAAS,SACnBwQ,EAAeK,oBAAoBT,EAAOG,EAAS5B,SAUtEnJ,EAAUxF,SAAS,WACpBuQ,EAAU,EAAEvM,EAAWtC,IACZkB,IACHoB,EAAUsN,KAAKC,eAAgB,EAC/B7P,EAAKkB,IACgC,IAAjCoB,EAAUsN,KAAKC,eACfvN,EAAUsN,KAAKE,iBAAiBhM,EAAUxF,SAAS,iBALrD,CAQPgE,EAAWuM,IAGd/K,EAAUxF,SAAS,YAAa,CAC5ByR,IAAAA,EAAejM,EAAUA,EAAUL,QAAQ,YAAc,IAAM,eAC/DxD,GAAO,EAAU8P,EAAAA,WAAAA,EAAaxL,MAAM,MAAM,IAAM0E,OAAO8G,EAAaxL,MAAM,MAAM,IAAM,IAC1FsK,GAAU,EAASA,EAAAA,UAAAA,EAAS5O,EAAM,MAEhC+P,MAAAA,EAAgBlM,EAAUsE,KAAK6H,GAAKA,EAAE/L,WAAW,UACnD8L,QAAkBrE,IAAlBqE,EAA6B,CACvBE,MAAAA,EAAUF,EAAczL,MAAM,KAAK4L,MAAM,GAAG1J,KAAK,KACnD2J,IAAAA,EAAYtM,EAAUA,EAAUL,QAAQuM,GAAiB,GAEzDE,GADJE,OAA0BzE,IAAdyE,GAA2BA,EAAUC,SAAS,MAAQC,SAASF,EAAUG,OAAO,EAAGH,EAAUvC,OAAS,IAAM,SACxGlC,IAAZuE,EACArB,EAAU,EAAE2B,EAAMxQ,IACNkB,IACAuP,IAAAA,EAAUrB,OAAO7O,WAAW,WAAcP,EAAKkB,IAAMkP,GACzDI,EAAKE,cAActC,KAAKqC,IAHtB,CAMPnO,EAAWuM,OACX,CACCrH,IAAAA,GAAQ,IAAImJ,MAAOC,UAMnBR,QALoDzE,IAApDrJ,EAAUuO,6BAA6BX,KACvC1I,EAAQlF,EAAUuO,6BAA6BX,GAAS1I,MACxD4I,IAA0B,IAAIO,MAAOC,UAAapJ,KAGlD4I,EAAY,GAcT,YAEH9N,EAAUwO,cAAc1C,KAAK,KACzBS,EAAQ,IAAIkC,YAAY,QAAS,CAACrB,OAAQ,CAACX,OAAQpQ,QAhBvDkQ,EAAU,EAAE2B,EAAMxQ,IACNkB,IACAuP,IAAAA,EAAUrB,OAAO7O,WAAW,kBACrBiQ,EAAKQ,YAAYd,GACxBd,OAAO9O,aAAamQ,GACpBzQ,EAAKkB,IACNkP,GACHI,EAAKQ,YAAYd,GAAW,CACxBe,GAAIR,EACJjJ,MAAOA,IATT,CAYPlF,EAAWuM,IAWZ,UAAVH,EACOC,GAAW7K,EAAUxF,SAAS,SACjCgE,EAAUwO,cAAc1C,KAAK,KACzBS,EAAQ,IAAIkC,YAAY,QAAS,CAACrB,OAAO,CAAEX,OAAQpQ,cAKhCgN,IAAvBhN,EAAGuS,kBACHvS,EAAGuS,gBAAkB,IAEzBvS,EAAGuS,gBAAgB9C,KAAK,CAACU,EAAgBJ,EAAOG,EAAS5B,IACzD6B,EAAejR,iBAAiB6Q,EAAOG,EAAS5B,IAIxD,SAASiC,EAAmB5M,EAAW5B,EAAYQ,EAAGwI,EAAWyH,GACvDpC,MAAAA,EAAoB,UAAX7N,EAAEqB,KAAkBrB,EAAEwO,OAAF,OAAqBxO,EAAE6N,OACnDzM,OAAAA,EAAU8O,0BAA0BrC,EAAQrO,EAAY,KACpD,IAAKgJ,IAAuBxI,OAAAA,EAAYiQ,MAAAA,KAIvD,SAAS7B,EAAWZ,GACT,MAAA,CAAC,UAAW,SAASpQ,SAASoQ,GAGzC,SAASa,EAA+CrO,EAAG4C,GACnDuN,IAAAA,EAAevN,EAAUpB,OAAOQ,IACxB,CAAC,SAAU,WAAY,UAAW,QAAQ5E,SAAS4E,IAG3DmO,GAAAA,EAAa/S,SAAS,YAAa,CAC/BgT,IAAAA,EAAgBD,EAAa5N,QAAQ,YACzC4N,EAAaE,OAAOD,GAAe,EAAU,EAAA,YAACD,EAAaC,EAAgB,IAAM,gBAAgB/M,MAAM,MAAM,IAAM,EAAI,GAIvH8M,GAAwB,IAAxBA,EAAaxD,OAAc,OAAO,EAGlCwD,GAAwB,IAAxBA,EAAaxD,QAAgBwD,EAAa,KAAOG,EAActQ,EAAEmF,KAAM,OAAO,EAG5EoL,MACAC,EADqB,CAAC,OAAQ,QAAS,MAAO,OAAQ,MAAO,SACbhP,OAAOiP,GAAYN,EAAa/S,SAASqT,IAI3FD,GAFJL,EAAeA,EAAa3O,OAAOQ,IAAMwO,EAA2BpT,SAAS4E,IAEzEwO,EAA2B7D,OAAS,EAAG,CASnC+D,GARgCF,EAA2BhP,OAAOiP,IAEjD,QAAbA,GAAmC,UAAbA,IAAsBA,EAAW,QAEpDzQ,KAAKyQ,UAIgB9D,SAAW6D,EAA2B7D,QAE9DwD,EAAa,KAAOG,EAActQ,EAAEmF,KAAM,OAAO,EAKtD,OAAA,EAGX,SAASmL,EAAcnL,GACXA,OAAAA,GACC,IAAA,IACM,MAAA,QACN,IAAA,IACA,IAAA,WACM,MAAA,QACX,QACWA,OAAAA,IAAO,EAAUA,EAAAA,WAAAA;;ACvJnC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,sBAAA,EA9DD,IAAA,EAAA,QAAA,QACA,EAAA,QAAA,YAEO,SAASwL,EAAsBvP,EAAW3D,EAAImF,EAAWpD,EAAYgJ,GAGpEgF,IAAAA,EAAsC,WAA7B/P,EAAGE,QAAQC,eACjB,CAAC,WAAY,SAASR,SAASK,EAAG4D,OAClCuB,EAAUxF,SAAS,QACpB,SAAW,QAEXwT,MAAAA,KAAwBpR,qCAA8CA,MAE3D4B,EAAAA,EAAAA,kBAAAA,EAAW3D,EAAI+P,EAAO5K,EAAWgO,EAAoB,KAC3D,IACApI,IACHqI,sBAAuBC,EAAgCrT,EAAImF,EAAWpD,MAKlF,SAASsR,EAAgCrT,EAAImF,EAAWpD,GAQ7C,MAPS,UAAZ/B,EAAG4D,OAIG5D,EAAGsT,aAAa,SAAStT,EAAG8N,aAAa,OAAQ/L,IAGpD,CAACgO,EAAOwD,KAEPxD,GAAAA,aAAiBqC,aAAerC,EAAMgB,OAC/BhB,OAAAA,EAAMgB,OACV,GAAgB,aAAZ/Q,EAAG4D,KAAqB,CAE3BvE,GAAAA,MAAMoL,QAAQ8I,GAAe,CACvBC,MAAAA,EAAWrO,EAAUxF,SAAS,UAAY8T,EAAgB1D,EAAMK,OAAO/N,OAAS0N,EAAMK,OAAO/N,MAC5F0N,OAAAA,EAAMK,OAAOzC,QAAU4F,EAAalP,OAAO,CAACmP,IAAaD,EAAaxP,OAAO/D,KAAO,EAAwBA,EAAAA,yBAAAA,EAAIwT,IAEhHzD,OAAAA,EAAMK,OAAOzC,QAErB,GAAiC,WAA7B3N,EAAGE,QAAQC,eAA8BH,EAAG0T,SAC5CvO,OAAAA,EAAUxF,SAAS,UACpBN,MAAMC,KAAKyQ,EAAMK,OAAOuD,iBAAiB3P,IAAIuK,IAEpCkF,OAAAA,EADUlF,EAAOlM,OAASkM,EAAOE,QAG1CpP,MAAMC,KAAKyQ,EAAMK,OAAOuD,iBAAiB3P,IAAIuK,GACpCA,EAAOlM,OAASkM,EAAOE,MAEnC,CACG7G,MAAAA,EAAWmI,EAAMK,OAAO/N,MACvB8C,OAAAA,EAAUxF,SAAS,UACpB8T,EAAgB7L,GACfzC,EAAUxF,SAAS,QAAUiI,EAASoB,OAASpB,IAKlE,SAAS6L,EAAgB7L,GACfgM,MAAAA,EAAShM,EAAWiM,WAAWjM,GAAY,KAC1C,OAAA,EAAUgM,EAAAA,WAAAA,GAAUA,EAAShM;;;AC6exC,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAviBA,MAAM,QAAE6C,GAAYpL,OACd,eAAE4D,EAAgB6Q,OAAQC,EAAcC,eAAgBC,EAAxD,aAA8EC,EAA9E,yBAA4FC,EAA5F,oBAAsHC,EAAtH,sBAA2IC,EAA3I,kBAAkKC,EAAlK,eAAqLC,GAAoBtS,QACvMwN,KAAM+E,EAAWnQ,OAAQoQ,GAAiBpV,MAAMqV,UAClDC,EAAM,GAAGC,SACf,SAASA,EAASC,GACVA,OAAAA,GAAOA,EAAID,SACJC,EAAID,WAES,iBAARC,EACLF,EAAIhS,KAAKkS,GAGTA,EAAM,GAGrB,SAASC,EAAYD,GACVA,YAAQ7H,IAAR6H,EAEX,SAASE,EAAWF,GACT,MAAe,mBAARA,EAElB,MAAMG,EAAkB,IAAIC,QAC5B,SAASC,EAAcC,EAAO9S,GAC1B2S,EAAgBI,IAAID,EAAO9S,GAE/B,MAAMgT,EAAUC,GAAiBN,EAAgBO,IAAID,IAAiBA,EAEtE,MAAME,EACFtS,YAAYuS,EAAUpT,GACbqT,KAAAA,eAAiBrT,EACjBoT,KAAAA,SAAWA,EAGpBE,eAAeC,GACPrB,GAAAA,EAAe5R,KAAKiT,EAAY,SAChCA,EAAWvT,MAAQ,KAAKwT,UAAUD,EAAWvT,WAE5C,CACK,MAAE+S,IAAKU,EAAaP,IAAKQ,GAAgBH,EAC1Cd,EAAYiB,KACbH,EAAWL,IAAM,KAAKS,WAAWD,IAEhCjB,EAAYgB,KACbF,EAAWR,IAAM,KAAKa,WAAWH,IAGlCF,OAAAA,EAEXM,+BAA+BC,EAAczO,GACnC,MAAA,eAAEgO,GAAmB,KAIrBU,EAAqBjC,EAAyBuB,EAAgBhO,GAGhE,IAACoN,EAAYsB,GAAqB,CAC5BC,MAAAA,EAAc,KAAKV,eAAeS,GACxCnC,EAAqBkC,EAAczO,EAAK2O,IAGhDC,iBAAiBH,GACP,MAAA,eAAET,GAAmB,KACRjB,EAAY9R,KAAKyR,EAAoBsB,GAAiBrB,EAAsBqB,IACpFrK,QAAS3D,IACXwO,KAAAA,+BAA+BC,EAAczO,KAEhD,MAAE+N,UAAU,eAAEc,IAAqB,KACpCzB,EAAYyB,IAAoBhC,EAAe5R,KAAKwT,EAAcI,IACnEtC,EAAqBkC,EAAcI,EAAgBxC,EAAa,OAEpEO,EAAkB6B,GAKtBtU,MAAMsU,EAAcK,EAASC,IAK7BC,UAAUP,EAAcM,EAAUE,IAGlCpB,IAAIY,EAAczO,GACR,MAAA,eAAEgO,EAAgBD,UAAU,cAAEmB,IAAoB,KAClDvU,EAAQqT,EAAehO,GAEtB,OADPkP,EAAclB,EAAgBhO,GACvB,KAAKmO,UAAUxT,GAE1BwU,IAAIV,EAAczO,GACR,MAAA,eAAEgO,EAAgBD,UAAU,eAAEc,EAAF,cAAkBK,IAAoB,KAIjElP,OAHPkP,EAAclB,EAAgBhO,GAGvBA,KAAOgO,GAAkBhO,IAAQ6O,EAE5CO,QAAQX,GACE,MAAA,eAAET,EAAgBD,UAAU,eAAEc,IAAqB,KAEnD1T,EAAOiS,EAAYyB,IAAmBhC,EAAe5R,KAAK+S,EAAgBa,GAAkB,GAAK,CAACA,GAIjG1T,OAFP2R,EAAU3S,MAAMgB,EAAMuR,EAAoBsB,IAC1ClB,EAAU3S,MAAMgB,EAAMwR,EAAsBqB,IACrC7S,EAEXqR,aAAaiC,GACH,MAAA,eAAET,GAAmB,KAEvB,QAACxB,EAAaiC,OAGbjC,EAAawB,KACTY,KAAAA,iBAAiBH,IACf,IAIflT,eAAekT,GACL,MAAA,eAAET,GAAmB,KACpBzS,OAAAA,EAAeyS,GAE1BvB,yBAAyBgC,EAAczO,GAC7B,MAAA,eAAEgO,EAAgBD,UAAU,cAAEmB,EAAF,eAAiBL,IAAqB,KAExEK,EAAclB,EAAgBhO,GAC1BqP,IAAAA,EAAO5C,EAAyBuB,EAAgBhO,GAChDoN,GAAAA,EAAYiC,GAAO,CACfrP,GAAAA,IAAQ6O,EACDvJ,OAMJ+J,OADP9C,EAAqBkC,EAAcI,EADnCQ,EAAO,CAAE1U,WAAO2K,EAAWgK,UAAU,EAAOC,cAAc,EAAOC,YAAY,IAEtEH,EASJ,OAPmB,IAAtBA,EAAKE,cAEAf,KAAAA,+BAA+BC,EAAczO,GAK/C,KAAKiO,eAAeoB,IAInC,MAAMI,EAAc,IAAIlC,QAClBmC,EAAc,IAAInC,QAClBoC,EAAmB,IAAIpC,QACvBqC,EAAmB,IAAIrC,QAC7B,MAAMsC,UAA6B/B,EAC/BK,UAAUxT,GACC,OAAA,KAAKoT,SAAS+B,SAASnV,GAElC2T,WAAWD,GACD0B,MAAAA,EAAgBN,EAAY5B,IAAIQ,GAClC,IAACjB,EAAY2C,GACNA,OAAAA,EAELvH,MAAAA,EAAU,KACVqF,EAAM,WAEDrF,OAAAA,EAAQ2F,UAAUE,EAAYpT,KAAK0S,EAAO,SAI9CE,OAFP4B,EAAY/B,IAAIW,EAAaR,GAC7B8B,EAAiBjC,IAAIG,EAAKQ,GACnBR,EAEXU,WAAWH,GACD4B,MAAAA,EAAgBN,EAAY7B,IAAIO,GAClC,IAAChB,EAAY4C,GACNA,OAAAA,EAELtC,MAAAA,EAAM,SAAUuC,GAElB7B,EAAYnT,KAAK0S,EAAO,MAAOA,EAAOsC,KAInCvC,OAFPgC,EAAYhC,IAAIU,EAAaV,GAC7BkC,EAAiBlC,IAAIA,EAAKU,GACnBV,EAEXwC,iBAAiBhC,GACTrB,GAAAA,EAAe5R,KAAKiT,EAAY,SAEhCA,EAAWvT,MAAQgT,EAAOO,EAAWvT,WAEpC,CACK,MAAA,IAAE+S,EAAF,IAAOG,GAAQK,EAChBd,EAAYS,KACbK,EAAWL,IAAM,KAAKsC,aAAatC,IAElCT,EAAYM,KACbQ,EAAWR,IAAM,KAAK0C,aAAa1C,IAGpCQ,OAAAA,EAEXiC,aAAaE,GACHC,MAAAA,EAAgBX,EAAiB9B,IAAIwC,GACvC,IAACjD,EAAYkD,GACNA,OAAAA,EAEL9H,MAAAA,EAAU,KACVqF,EAAM,WAEDF,OAAAA,EAAO0C,EAAOpV,KAAKuN,EAAQ2F,UAAU,SAIzCN,OAFP4B,EAAY/B,IAAIG,EAAKwC,GACrBV,EAAiBjC,IAAI2C,EAAQxC,GACtBA,EAEXuC,aAAaG,GACHC,MAAAA,EAAgBZ,EAAiB/B,IAAI0C,GACvC,IAACnD,EAAYoD,GACNA,OAAAA,EAELhI,MAAAA,EAAU,KACVkF,EAAM,SAAUuC,GAElBM,EAAOtV,KAAKuN,EAAQ2F,UAAU,MAAO3F,EAAQ2F,UAAU8B,KAIpDvC,OAFPgC,EAAYhC,IAAIA,EAAK6C,GACrBX,EAAiBlC,IAAI6C,EAAQ7C,GACtBA,EAEXA,IAAIe,EAAczO,EAAKrF,GACb,MAAA,eAAEqT,EAAgBD,UAAU,aAAE0C,IAAmB,KAahD,OAZUzC,EAAehO,KACfrF,GACbqT,EAAehO,GAAOrF,EACtB8V,EAAazC,EAAgBhO,IAEhB,WAARA,GAAoB+C,EAAQiL,IAKjCyC,EAAazC,EAAgBhO,IAE1B,EAEX0Q,eAAejC,EAAczO,GACnB,MAAA,eAAEgO,EAAgBD,UAAU,aAAE0C,IAAmB,KAGhD,cAFAzC,EAAehO,GACtByQ,EAAazC,EAAgBhO,IACtB,EAEX2Q,eAAelC,EAAczB,GAErB,EAIRJ,kBAAkB6B,GACVjC,GAAAA,EAAaiC,GAAe,CACtB,MAAA,eAAET,GAAmB,KASvBxB,GARJI,EAAkBoB,GAQdxB,EAAawB,GACN,OAAA,EAENY,KAAAA,iBAAiBH,GAEnB,OAAA,EAEXnC,eAAemC,EAAczO,EAAKkO,GACxB,MAAA,eAAEF,EAAgBD,UAAU,aAAE0C,EAAF,eAAgB5B,IAAqB,KACnE7O,OAAAA,IAAQ6O,IAAmBhC,EAAe5R,KAAK+S,EAAgBhO,KAQnEuM,EAAqByB,EAAgBhO,EAAK,KAAKkQ,iBAAiBhC,KAEhC,IAA5BA,EAAWqB,cACNf,KAAAA,+BAA+BC,EAAczO,GAEtDyQ,EAAazC,EAAgBhO,IACtB,IAIf,MAAM4Q,EAAY,IAAIrD,QAChBsD,EAAY,IAAItD,QACtB,MAAMuD,UAAwBhD,EAC1BK,UAAUxT,GACC,OAAA,KAAKoT,SAASgD,iBAAiBpW,GAE1C2T,WAAWD,GACD0B,MAAAA,EAAgBa,EAAU/C,IAAIQ,GAChC,IAACjB,EAAY2C,GACNA,OAAAA,EAELvH,MAAAA,EAAU,KACVqF,EAAM,WAEDrF,OAAAA,EAAQ2F,UAAUE,EAAYpT,KAAK0S,EAAO,SAG9CE,OADP+C,EAAUlD,IAAIW,EAAaR,GACpBA,EAEXU,WAAWH,GACD4B,MAAAA,EAAgBa,EAAUhD,IAAIO,GAChC,IAAChB,EAAY4C,GACNA,OAAAA,EAELxH,MACAkF,EAAM,SAAUuC,GAEd,GAMDvC,OADPmD,EAAUnD,IAAIU,EAAaV,GACpBA,EAEXA,IAAIe,EAAczO,EAAKrF,GAUZ,OAAA,EAEX+V,eAAejC,EAAczO,GAOlB,OAAA,EAEX2Q,eAAelC,EAAczB,GAErB,EAKRJ,kBAAkB6B,GAOP,OAAA,EAEXnC,eAAemC,EAAczO,EAAKkO,GAOvB,OAAA,GAIf,SAAS8C,EAAQC,GACTlO,GAAAA,EAAQkO,GACDA,OAAAA,EAAc3U,IAAKsH,IAChBsN,MAAAA,EAAWvD,EAAO/J,GACpBsN,OAAAA,IAAatN,EACNoN,EAAQE,GAEZtN,IAGTuJ,MAAAA,EAAMd,EAAa9Q,EAAe0V,IAClCE,EAAQzE,EAAoBuE,GAC3BlE,OAAAA,EAAY9R,KAAKkW,EAAOxE,EAAsBsE,IAChDG,OAAO,CAACC,EAAMrR,KACT4D,MAAAA,EAAOqN,EAAcjR,GACrBkR,EAAWvD,EAAO/J,GAOjByN,OALHA,EAAKrR,GADLkR,IAAatN,EACDoN,EAAQE,GAGRtN,EAETyN,GACRlE,GAEP,MAAMmE,EAAY,CACdC,OAASC,IACCxD,MAAAA,EAAiBL,EAAO6D,GAE1B,OAACxD,GAAkBA,IAAmBwD,EAInC,CAAC,SAAU,CAAEC,OADRT,EAAQQ,KAFT,MAKfE,QAAS,KACE,EAEX1I,KAAM,IACK,MAMf,SAAS2I,IAGD,MAAsB,oBAAfC,WACAA,WAES,oBAAT9G,KACAA,KAEW,oBAAX/B,OACAA,YAEW,IAAX8I,EACAA,EAGJ,GAEX,SAASC,IAIK,MAAA,IAAIC,eAgBlB,MAAMC,EAAqBzX,OAAOyS,UAClC,SAASiF,EAAyBtX,GAE1BA,GAAU,OAAVA,EACO,OAAA,EAGP,GAAiB,iBAAVA,EACA,OAAA,EAEPoI,GAAAA,EAAQpI,GACD,OAAA,EAELuX,MAAAA,EAAQ3W,EAAeZ,GACrBuX,OAAAA,IAAUF,GAAgC,OAAVE,GAA4C,OAA1B3W,EAAe2W,GAE7E,MAAMC,EAAuB,CAAChF,EAAKnN,OAG7BoS,EAAsB,CAACjF,EAAKnN,OAG5BqS,EAA0B1X,GAAUA,EAC1C,SAAS2X,EAAmB3X,GACjBoI,OAAAA,EAAQpI,GAAS,GAAK,GAEjC,MAAM4X,EACF/W,YAAYoL,GAOJ,GANC4L,KAAAA,gBAAkBH,EAClB5B,KAAAA,aAAe2B,EACflD,KAAAA,cAAgBiD,EAChBM,KAAAA,kBAAoBR,EACpBS,KAAAA,oBAAsB,IAAInF,QAC1BoF,KAAAA,oBAAsB,IAAIpF,SAC1BH,EAAYxG,GAAU,CACjB,MAAA,gBAAE4L,EAAF,aAAmB/B,EAAnB,cAAiCvB,EAAjC,kBAAgDuD,EAAhD,eAAmE5D,GAAmBjI,EACvF4L,KAAAA,gBAAkBnF,EAAWmF,GAAmBA,EAAkBH,EAClE5B,KAAAA,aAAepD,EAAWoD,GAAgBA,EAAe2B,EACzDlD,KAAAA,cAAgB7B,EAAW6B,GAAiBA,EAAgBiD,EAC5DM,KAAAA,kBAAoBpF,EAAWoF,GAAqBA,EAAoBR,EACxEpD,KAAAA,eAAiBA,GAG9BiB,SAASnV,GACCiY,MAAAA,EAAiBjF,EAAOhT,GACxBkY,EAAY,KAAKL,gBAAgBI,GACnC,OAAA,KAAKH,kBAAkBI,GACnB,KAAKH,oBAAoB7E,IAAIgF,KAAelY,EAGrCA,EAEJ,KAAKmY,mBAAmBF,EAAgBC,GAE5CA,EAEX9B,iBAAiBpW,GACbA,EAAQgT,EAAOhT,GACTkY,MAAAA,EAAY,KAAKL,gBAAgB7X,GACnC,OAAA,KAAK8X,kBAAkBI,GAChB,KAAKE,mBAAmBpY,EAAOkY,GAEnCA,EAEXG,YAAYC,GACDtF,OAAAA,EAAOsF,GAElBH,mBAAmBnY,EAAOuY,GAClBzF,IAAAA,EAAQ,KAAKkF,oBAAoB9E,IAAIqF,GACrC9F,GAAAA,EAAYK,GAAQ,CAEdjF,MAAAA,EAAU,IAAIqH,EAAqB,KAAMqD,GAE/C1F,EADAC,EAAQ,IAAI0F,MAAMb,EAAmBY,GAAiB1K,GACjC7N,GAChBgY,KAAAA,oBAAoBjF,IAAIwF,EAAgBzF,GAE1CA,OAAAA,EAEXsF,mBAAmBpY,EAAOuY,GAClBzF,IAAAA,EAAQ,KAAKiF,oBAAoB7E,IAAIqF,GACrC9F,GAAAA,EAAYK,GAAQ,CAEdjF,MAAAA,EAAU,IAAIsI,EAAgB,KAAMoC,GAE1C1F,EADAC,EAAQ,IAAI0F,MAAMb,EAAmBY,GAAiB1K,GACjC7N,GAChB+X,KAAAA,oBAAoBhF,IAAIwF,EAAgBzF,GAE1CA,OAAAA,GAKf,QAAA,QAAA;;ACtdA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,OAAA,EApFA,IAAA,EAAA,EAAA,QAAA,wBAoFA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAlFO,SAAS2F,EAAKC,EAAMC,GAMnBvF,IAAAA,EAAW,IAAIwF,EAAJ,QAAuB,CAClC9C,aAAa/H,EAAQ1I,GACjBsT,EAAiB5K,EAAQ1I,MAI1B,MAAA,CACHqT,KAAMtF,EAAS+B,SAASuD,GACxBtF,SAAUA,GAIX,SAASJ,EAAOI,EAAUyF,GACzBC,IAAAA,EAAgB1F,EAASiF,YAAYQ,GACrCE,EAAO,GAQJA,OANPnZ,OAAOY,KAAKsY,GAAe9P,QAAQ3D,IAC3B,CAAC,MAAO,QAAS,YAAa,SAAU,QAAQ/H,SAAS+H,KAE7D0T,EAAK1T,GAAOyT,EAAczT,MAGvB0T;;;AC7BX,IAOIC,EACAC,EARAC,EAAUC,OAAOC,QAAU,GAU/B,SAASC,IACC,MAAA,IAAIC,MAAM,mCAEpB,SAASC,IACC,MAAA,IAAID,MAAM,qCAsBpB,SAASE,EAAWC,GACZT,GAAAA,IAAqBzZ,WAEdA,OAAAA,WAAWka,EAAK,GAGvB,IAACT,IAAqBK,IAAqBL,IAAqBzZ,WAEzDA,OADPyZ,EAAmBzZ,WACZA,WAAWka,EAAK,GAEvB,IAEOT,OAAAA,EAAiBS,EAAK,GAC/B,MAAMvZ,GACA,IAEO8Y,OAAAA,EAAiB1Y,KAAK,KAAMmZ,EAAK,GAC1C,MAAMvZ,GAEG8Y,OAAAA,EAAiB1Y,KAAK,KAAMmZ,EAAK,KAMpD,SAASC,EAAgBC,GACjBV,GAAAA,IAAuB3Z,aAEhBA,OAAAA,aAAaqa,GAGpB,IAACV,IAAuBM,IAAwBN,IAAuB3Z,aAEhEA,OADP2Z,EAAqB3Z,aACdA,aAAaqa,GAEpB,IAEOV,OAAAA,EAAmBU,GAC5B,MAAOzZ,GACD,IAEO+Y,OAAAA,EAAmB3Y,KAAK,KAAMqZ,GACvC,MAAOzZ,GAGE+Y,OAAAA,EAAmB3Y,KAAK,KAAMqZ,MAjEhD,WACO,IAEIX,EADsB,mBAAfzZ,WACYA,WAEA8Z,EAEzB,MAAOnZ,GACL8Y,EAAmBK,EAEnB,IAEIJ,EADwB,mBAAjB3Z,aACcA,aAEAia,EAE3B,MAAOrZ,GACL+Y,EAAqBM,GAjB5B,GAwED,IAEIK,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAa/M,OACbgN,EAAQD,EAAa5X,OAAO6X,GAE5BE,GAAc,EAEdF,EAAMhN,QACNoN,KAIR,SAASA,IACDH,IAAAA,EAAAA,CAGA5a,IAAAA,EAAUsa,EAAWQ,GACzBF,GAAW,EAGLI,IADFA,IAAAA,EAAML,EAAMhN,OACVqN,GAAK,CAGA,IAFPN,EAAeC,EACfA,EAAQ,KACCE,EAAaG,GACdN,GACAA,EAAaG,GAAYI,MAGjCJ,GAAc,EACdG,EAAML,EAAMhN,OAEhB+M,EAAe,KACfE,GAAW,EACXJ,EAAgBxa,IAiBpB,SAASkb,EAAKX,EAAK1c,GACV0c,KAAAA,IAAMA,EACN1c,KAAAA,MAAQA,EAYjB,SAASsd,KA5BTnB,EAAQoB,SAAW,SAAUb,GACrBra,IAAAA,EAAO,IAAIpC,MAAMqC,UAAUwN,OAAS,GACpCxN,GAAAA,UAAUwN,OAAS,EACd,IAAA,IAAI3K,EAAI,EAAGA,EAAI7C,UAAUwN,OAAQ3K,IAClC9C,EAAK8C,EAAI,GAAK7C,UAAU6C,GAGhC2X,EAAMzM,KAAK,IAAIgN,EAAKX,EAAKra,IACJ,IAAjBya,EAAMhN,QAAiBiN,GACvBN,EAAWS,IASnBG,EAAK/H,UAAU8H,IAAM,WACZV,KAAAA,IAAIja,MAAM,KAAM,KAAKzC,QAE9Bmc,EAAQqB,MAAQ,UAEhBrB,EAAQsB,IAAM,GACdtB,EAAQuB,KAAO,GACfvB,EAAQwB,QAAU,GAClBxB,EAAQyB,SAAW,GAInBzB,EAAQ0B,GAAKP,EACbnB,EAAQ2B,YAAcR,EACtBnB,EAAQrR,KAAOwS,EACfnB,EAAQ4B,IAAMT,EACdnB,EAAQ6B,eAAiBV,EACzBnB,EAAQ8B,mBAAqBX,EAC7BnB,EAAQ+B,KAAOZ,EACfnB,EAAQgC,gBAAkBb,EAC1BnB,EAAQiC,oBAAsBd,EAE9BnB,EAAQkC,UAAY,SAAUla,GAAe,MAAA,IAE7CgY,EAAQmC,QAAU,SAAUna,GAClB,MAAA,IAAIoY,MAAM,qCAGpBJ,EAAQoC,IAAM,WAAqB,MAAA,KACnCpC,EAAQqC,MAAQ,SAAUC,GAChB,MAAA,IAAIlC,MAAM,mCAEpBJ,EAAQuC,MAAQ,WAAoB,OAAA;;;ACuHpC,IAAA,EAAA,QAAA,WAlRA,SAAA,EAAA,EAAA,GAGA,IADA,IAAA,EAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,MAAA,EACA,EAAA,OAAA,EAAA,GACA,OAAA,GACA,EAAA,OAAA,EAAA,GACA,KACA,IACA,EAAA,OAAA,EAAA,GACA,KAKA,GAAA,EACA,KAAA,IAAA,EACA,EAAA,QAAA,MAIA,OAAA,EAmJA,SAAA,EAAA,GACA,iBAAA,IAAA,GAAA,IAEA,IAGA,EAHA,EAAA,EACA,GAAA,EACA,GAAA,EAGA,IAAA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EACA,GAAA,KAAA,EAAA,WAAA,IAGA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,YAEA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAIA,OAAA,IAAA,EAAA,GACA,EAAA,MAAA,EAAA,GA8DA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,OAAA,OAAA,EAAA,OAAA,GAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAEA,OAAA,EA3OA,QAAA,QAAA,WAIA,IAHA,IAAA,EAAA,GACA,GAAA,EAEA,EAAA,UAAA,OAAA,EAAA,IAAA,IAAA,EAAA,IAAA,CACA,IAAA,EAAA,GAAA,EAAA,UAAA,GAAA,EAAA,MAGA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,6CACA,IAIA,EAAA,EAAA,IAAA,EACA,EAAA,MAAA,EAAA,OAAA,IAWA,OAAA,EAAA,IAAA,KAJA,EAAA,EAAA,EAAA,EAAA,MAAA,KAAA,SAAA,GACA,QAAA,KACA,GAAA,KAAA,OAEA,KAKA,QAAA,UAAA,SAAA,GACA,IAAA,EAAA,QAAA,WAAA,GACA,EAAA,MAAA,EAAA,GAAA,GAcA,OAXA,EAAA,EAAA,EAAA,EAAA,MAAA,KAAA,SAAA,GACA,QAAA,KACA,GAAA,KAAA,OAEA,IACA,EAAA,KAEA,GAAA,IACA,GAAA,MAGA,EAAA,IAAA,IAAA,GAIA,QAAA,WAAA,SAAA,GACA,MAAA,MAAA,EAAA,OAAA,IAIA,QAAA,KAAA,WACA,IAAA,EAAA,MAAA,UAAA,MAAA,KAAA,UAAA,GACA,OAAA,QAAA,UAAA,EAAA,EAAA,SAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,0CAEA,OAAA,IACA,KAAA,OAMA,QAAA,SAAA,SAAA,EAAA,GAIA,SAAA,EAAA,GAEA,IADA,IAAA,EAAA,EACA,EAAA,EAAA,QACA,KAAA,EAAA,GADA,KAKA,IADA,IAAA,EAAA,EAAA,OAAA,EACA,GAAA,GACA,KAAA,EAAA,GADA,KAIA,OAAA,EAAA,EAAA,GACA,EAAA,MAAA,EAAA,EAAA,EAAA,GAfA,EAAA,QAAA,QAAA,GAAA,OAAA,GACA,EAAA,QAAA,QAAA,GAAA,OAAA,GAsBA,IALA,IAAA,EAAA,EAAA,EAAA,MAAA,MACA,EAAA,EAAA,EAAA,MAAA,MAEA,EAAA,KAAA,IAAA,EAAA,OAAA,EAAA,QACA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,EAAA,EACA,MAIA,IAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAAA,MAKA,OAFA,EAAA,EAAA,OAAA,EAAA,MAAA,KAEA,KAAA,MAGA,QAAA,IAAA,IACA,QAAA,UAAA,IAEA,QAAA,QAAA,SAAA,GAEA,GADA,iBAAA,IAAA,GAAA,IACA,IAAA,EAAA,OAAA,MAAA,IAKA,IAJA,IAAA,EAAA,EAAA,WAAA,GACA,EAAA,KAAA,EACA,GAAA,EACA,GAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EAEA,GAAA,MADA,EAAA,EAAA,WAAA,KAEA,IAAA,EAAA,CACA,EAAA,EACA,YAIA,GAAA,EAIA,OAAA,IAAA,EAAA,EAAA,IAAA,IACA,GAAA,IAAA,EAGA,IAEA,EAAA,MAAA,EAAA,IAiCA,QAAA,SAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,GAIA,OAHA,GAAA,EAAA,QAAA,EAAA,EAAA,UAAA,IACA,EAAA,EAAA,OAAA,EAAA,EAAA,OAAA,EAAA,SAEA,GAGA,QAAA,QAAA,SAAA,GACA,iBAAA,IAAA,GAAA,IAQA,IAPA,IAAA,GAAA,EACA,EAAA,EACA,GAAA,EACA,GAAA,EAGA,EAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,WAAA,GACA,GAAA,KAAA,GASA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAEA,KAAA,GAEA,IAAA,EACA,EAAA,EACA,IAAA,IACA,EAAA,IACA,IAAA,IAGA,GAAA,QArBA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,OAuBA,OAAA,IAAA,IAAA,IAAA,GAEA,IAAA,GAEA,IAAA,GAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAEA,EAAA,MAAA,EAAA,IAaA,IAAA,EAAA,MAAA,KAAA,QAAA,GACA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,OAAA,EAAA,IACA,SAAA,EAAA,EAAA,GAEA,OADA,EAAA,IAAA,EAAA,EAAA,OAAA,GACA,EAAA,OAAA,EAAA;;AC1SyB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EADzB,IAAA,EAAA,QAAA,QACe,MAAMC,EACnB7a,YAAY8a,EAAaC,GAClBD,KAAAA,YAAcA,EACdC,KAAAA,SAAWA,EACX/M,KAAAA,eAAgB,EAEvBvO,KAAKub,KAAeC,GACbjN,KAAAA,eAAgB,EAEjBkN,IAAAA,EAAS,GACT3c,EAAO,GACW,IAAlB0c,EAAOjP,QAAgBiP,EAAO,GAAGjb,aAAejB,OAClDmc,EAASD,EAAO,GAEhB1c,EAAO0c,EAEJH,KAAAA,YAAYK,eACf,KAAKJ,SACLC,EACAzc,EACA2c,GAGJpP,UACOrM,KAAAA,KAAK,WAWZyS,IAAIkJ,EAAWjc,GAETA,GADC6O,KAAAA,eAAgB,EACjB7O,aAAiBkc,UAAYlc,aAAiBmc,KAC3CR,KAAAA,YAAYS,kBAAkB,KAAKR,SAAUK,EAAWjc,OACxD,CACD8b,IAAAA,EAAS,GACbA,EAAOG,GAAajc,EACf2b,KAAAA,YAAYU,qBACf,KAAKT,SACLE,IAINb,KAAKqB,EAAWP,EAAS,GAAIQ,EAAK,MAC3B1N,KAAAA,eAAgB,EAChB8M,KAAAA,YAAYa,eACf,KAAKZ,SACLU,EACAP,EACAQ,GAGJjb,UAAUmb,EAAkBV,EAAS,GAAIW,GAAsB,GACxD7N,KAAAA,eAAgB,EAEjB+M,IAAAA,EAAWa,GACV,EAAWA,EAAAA,YAAAA,KACdb,GAAW,EAAK,EAAA,MAAA,KAAKA,SAAUa,IAE7BE,IAAAA,EAAiB,GACjBC,EAAY,GACZxY,EAAQ,EACRyY,GAAa,EACbC,EAAgBlB,EAASrY,MAAM,KAC/BwZ,EAAoB,KAAKnB,SAASrY,MAAM,KACrCa,KAAAA,EAAQ0Y,EAAcjQ,SACR,IAAfgQ,IAGAC,EAAc1Y,KAAW2Y,EAAkB3Y,IAE1CA,IAAU0Y,EAAcjQ,OAAS,GAAKkP,IAAW,MAGpDc,GAAa,GAEVA,EAGHD,EAAUxP,KAAK0P,EAAc1Y,IAF7BuY,EAAevP,KAAK0P,EAAc1Y,IAIpCA,IAIKA,IADPA,EAAQ,EACDA,EAAQuY,EAAe9P,QACvB8O,KAAAA,YAAYU,qBACf,CACEO,EAAUnX,KAAK,KACfkX,EAAexN,MAAM,EAAG/K,EAAQ,GAAGqB,KAAK,MACxCA,KAAK,KACPrB,GAASuY,EAAe9P,OAAS,EAAIkP,EAAS,GAC9CW,GAEFtY,IAEK,OAAA,IAAIsX,EAAI,KAAKC,YAAaC,GAEnCoB,gBAAgBP,EAAkBV,EAAS,IAClC,OAAA,KAAKza,UAAUmb,EAAkBV,GAAQ,GAElDjN,gBAAgBmO,GAAc,GACvBtB,KAAAA,YAAY7M,gBAAgBmO,GAEnCC,iBAAiBxb,GACXA,YAAWiJ,IAAXjJ,EACK9B,OAAOY,KAAK,KAAKmb,YAAYwB,YAE7Bvd,OAAOa,OAAO,KAAKkb,YAAYwB,YAAYzb,OAAOA,GAAQC,IAAIyb,GAAKA,EAAExB,WAjHzD,QAAA,QAAA;;AC6BM,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAb/B,IAAA,EAAA,QAAA,WACA,EAAA,QAAA,oBACA,EAAA,QAAA,qBACA,EAAA,QAAA,qBACA,EAAA,QAAA,qBACA,EAAA,QAAA,qBACA,EAAA,QAAA,mBACA,EAAA,QAAA,sBACA,EAAA,QAAA,mBACA,EAAA,QAAA,gBAEA,EAAA,EAAA,QAAA,gBAE+B,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAhB,MAAMyB,EAKjBxc,YAAYlD,GACH2f,KAAAA,IAAM3f,EAEN4f,KAAAA,SAAU,EACV5B,KAAAA,iBAAchR,EACdiR,KAAAA,cAAWjR,EACX6S,KAAAA,WAAQ7S,EACR8S,KAAAA,aAAU9S,EACV+E,KAAAA,cAAgB,GAChBM,KAAAA,YAAc,GACdH,KAAAA,6BAA+B,GAC/B6N,KAAAA,sBAAmB/S,EAO5BgT,MAAMhC,EAAaC,EAAU4B,EAAOC,EAASG,GACrC,GAAA,KAAKL,UAED,KAAK5B,cAAgBA,GAClB,KAAKC,WAAaA,GAEjB,gDAA0C,KAAKA,eAAeA,IAEjE2B,KAAAA,SAAU,EAEV5B,KAAAA,YAAcA,EACdC,KAAAA,SAAWA,EACXhN,KAAAA,KAAO,IAAI8M,EAAJ,QAAQ,KAAKC,YAAa,KAAKC,eAErBjR,IAAtBiT,IACK/N,KAAAA,6BAA+B+N,EAAkB5N,aAEtDG,IAAAA,EAAO,KACN0N,KAAAA,YAAa,EAAS,EAAA,UAAA,WACvB1N,EAAKzG,eAAeyG,EAAKmN,MAC1B,GAGEE,KAAAA,MAAQM,KAAKC,MAAMD,KAAKE,UAAUR,IAClCC,KAAAA,QAAUA,EAEV,IAAA,MAAMxB,KAAarc,OAAOY,KAAK,KAAKgd,OACjC5d,OAAOY,KAAK,KAAKid,SAASngB,SAAS2e,IACnCle,QAAQC,qBAAqBie,mDAA2D,KAAKL,aAI/FqC,MAAAA,EAAY,KAAKX,IAAIvR,aAAa,aAClCmS,EAAiC,KAAdD,GAAkC,OAAdA,EAAsB,KAAOA,EACpEE,EAAW,KAAKb,IAAIvR,aAAa,YACjCqS,EAA+B,KAAbD,GAAgC,OAAbA,EAAqB,KAAOA,EACjEE,EAAa,KAAKf,IAAIvR,aAAa,cACnCuS,EAAmC,KAAfD,GAAoC,OAAfA,EAAuB,KAAOA,EACzEE,IAAAA,EAAa,CACbjB,IAAK,KAAKA,IACV1O,KAAM,KAAKA,MAG0B,KAAK0O,IAMzCkB,KAAAA,eAAiB,CAClBC,YAA+B9T,IAAtBiT,GACH,EAAU,EAAA,WAAA,KAAKN,IAAKY,EAAiBK,GACrCX,EAAkBc,oBAAlB,QAGV9e,OAAOqC,QAAQ,KAAKwb,SAASzU,QAAQ,EAAE6S,EAAY8C,MAC/C/e,OAAO+R,eACH,KAAK6M,kBACF3C,IACH,CAAE3I,IAAK,WAAqB,MAAA,IAAI4I,KAAkBlN,KAAAA,KAAKtO,KAAKub,KAAeC,SAInFlc,OAAOqC,QAAQ,KAAKub,OAAOxU,QAAQ,EAAE9H,EAAMlB,MAClCwe,KAAAA,eAAetd,GAAQlB,IAqB5B,IAAA,SAAEoT,EAAF,KAAYsF,GAAS,KAAKkG,qBAAqB,KAAKJ,gBAuCpDK,IAAAA,EAtCC9c,KAAAA,MAAQ2W,EACRtF,KAAAA,SAAWA,EAIXoL,KAAAA,eAAelB,IAAM,KAAKA,IAC1BkB,KAAAA,eAAeM,MAAQ,KAAKC,eAC5BP,KAAAA,eAAe5P,KAAO,KAAKA,KAC3B4P,KAAAA,eAAeX,WAAa,KAAKA,WACjCW,KAAAA,eAAeQ,SAAW,KAAKjd,MAE/B+N,KAAAA,cAAgB,GAChB0O,KAAAA,eAAeS,UAAatgB,CAAAA,IACxBmR,KAAAA,cAAc1C,KAAKzO,KAGvBugB,KAAAA,cAAiCvU,IAAtBiT,EAAkCA,EAAkBsB,SAAW,GAC1EV,KAAAA,eAAeW,OAAS,EAACC,EAAUzgB,KAC/B,KAAKugB,SAASE,KAAW,KAAKF,SAASE,GAAY,IACnDF,KAAAA,SAASE,GAAUhS,KAAKzO,KAc5BwO,KAAAA,mBAAqB,GACrBH,KAAAA,8BAMqBrC,IAAtBiT,GAAmCQ,GAG9BiB,KAAAA,iBAAkB,EACvBR,EAAuB,KAAK3X,yBAAyB,KAAKoW,IAAKc,GAC1DiB,KAAAA,iBAAkB,QACM1U,IAAtBiT,GAAmCU,IACrCe,KAAAA,iBAAkB,EACvBR,EAAuB,KAAK3X,yBAAyB,KAAKoW,IAAKgB,GAC1De,KAAAA,iBAAkB,GAOtBzV,KAAAA,mBAAmB,KAAK0T,IAAK,YAAiC3S,IAAtBiT,GAIxCF,KAAAA,iBAAmB,KAAK4B,mCAEO,mBAAzBT,GAGPA,EAAqBve,KAAK,KAAKyB,OAOvCwd,UACS,IAAA,MAAM9P,KAAW,KAAKC,cACvBtB,OAAO9O,aAAamQ,GAEnB,IAAA,MAAO+P,EAAWC,KAAc7f,OAAOqC,QAAQ,KAAK+N,aACrD5B,OAAO9O,aAAamgB,EAAUxP,IAE7ByN,KAAAA,iBAAiBgC,aACjBhC,KAAAA,sBAAmB/S,EAQ5B+T,oBACW,OAAA,EAAO,EAAA,QAAA,KAAKtL,SAAU,KAAKrR,OAGtC4d,qBAAqBC,EAAM7R,EAAQ1I,EAAM,GAAIwa,EAAQ,GAC7CjgB,GAAAA,OAAOkgB,GAAGF,EAAM7R,GACT1I,OAAAA,EAEL0a,MAAAA,EAAc/iB,MAAMoL,QAAQwX,GAC7B,IAAA,MAAO1e,EAAMlB,KAAUJ,OAAOqC,QAAQ2d,GACnC,KAAa,IAAVC,GAAe3e,EAAKgC,WAAW,MAAU6c,GAAwB,WAAT7e,IAAwC,iBAAVlB,GAAgC,OAAVA,EAAgB,CACzHggB,MAAAA,EAAU,KAAKL,qBAAqB3f,EAAO+N,EAAQ7M,EAAM2e,EAAQ,GACnEG,QAAYrV,IAAZqV,EACO3a,MAAQ,KAARA,KAAgBA,KAAO2a,IAAYA,GAK1DpB,qBAAqBlG,GACbvI,IAAAA,EAAO,KAEP8P,IAAAA,GAAY,EAAS,EAAA,UAAA,WACrB9P,EAAKzG,eAAeyG,EAAKmN,MAC1B,GAEI,OAAA,EAAK5E,EAAAA,MAAAA,EAAM,CAAC3K,EAAQ1I,KAEnB6a,IAAAA,EAAO,KAAKP,qBAAqB,KAAKnB,eAAgBzQ,QAC7CpD,IAATuV,GACKtR,KAAAA,KAAKmE,IAAa,KAATmN,EAAc7a,KAAS6a,KAAQ7a,IAAO0I,EAAO1I,IAE3DzF,OAAOkgB,GAAG/R,EAAQ,KAAKyQ,iBAAmB5e,OAAOY,KAAK,KAAKgd,OAAOlgB,SAAS+H,IACtEuJ,KAAAA,KAAKmE,IAAI1N,EAAK0I,EAAO1I,IAE1B8K,EAAK+O,SAAS7Z,GAEd8K,EAAK+O,SAAS7Z,GAAK2D,QAAQrK,GAAYA,EAASoP,EAAO1I,KAChDrI,MAAMoL,QAAQ2F,GAErBnO,OAAOY,KAAK2P,EAAK+O,UACZlW,QAAQmX,IACDC,IAAAA,EAAmBD,EAAmB5c,MAAM,KAKpC,WAAR8B,GAEJ+a,EAAiB3J,OAAO,CAAC4J,EAAgBC,KACjC1gB,OAAOkgB,GAAG/R,EAAQsS,EAAeC,KACjCnQ,EAAK+O,SAASiB,GAAoBnX,QAAQrK,GAAYA,EAASoP,IAG5DsS,EAAeC,IACvBnQ,EAAKqO,kBAKhB5e,OAAOY,KAAK2P,EAAK+O,UACZxd,OAAOQ,GAAKA,EAAE5E,SAAS,MACvB0L,QAAQmX,IACDC,IAAAA,EAAmBD,EAAmB5c,MAAM,KAI5C8B,IAAQ+a,EAAiBA,EAAiBvT,OAAS,IAIvDuT,EAAiB3J,OAAO,CAAC4J,EAAgBC,KACjC1gB,OAAOkgB,GAAG/R,EAAQsS,IAElBlQ,EAAK+O,SAASiB,GAAoBnX,QAAQrK,GAAYA,EAASoP,EAAO1I,KAGnEgb,EAAeC,IACvBnQ,EAAKqO,kBAKhBrO,EAAKkP,iBAETY,MAIRM,4BAA4B5iB,EAAIgB,EAAU6hB,EAA8B,WAC/D7iB,EAAAA,EAAAA,MAAAA,EAAIA,IAEDA,EAAGsT,aAAa,cAAetT,EAAGsT,aAAa,oBAE1CtT,EAAG0N,WAAW,KAAKiS,KASrB3e,EAAShB,IAPHA,EAAG8iB,OAAOD,EAA4B7iB,IAGpC,IAQvBiM,mBAAmB8W,EAAQhY,EAAY,SAAWiF,GAAU,GACnD4S,KAAAA,4BAA4BG,EAAQ/iB,QAEZgN,IAArBhN,EAAG6L,qBAGsBmB,IAAzBhN,EAAG6P,wBAEFmT,KAAAA,kBAAkBhjB,EAAI+K,EAAWiF,IACvChQ,IACCA,EAAG8iB,MAAQ,IAAIpD,EAAU1f,KAGxBuP,KAAAA,6CAEA0T,KAAAA,6BAA6BF,GAGtCC,kBAAkBhjB,EAAI+K,EAAWiF,GAAU,GAOnChQ,GAJAA,EAAGsT,aAAa,WAAY,EAAUtT,EAAAA,WAAAA,EAAI,MAAMkP,OAAS,IACzDlP,EAAG8J,wBAAyB,EAA0B9J,EAAAA,2BAAAA,EAAGoO,aAAa,gBAG/CpB,IAAvBhN,EAAGuS,gBAA+B,CAC7B,IAAA,MAAO2Q,EAASnT,EAAOG,EAAS5B,KAAYtO,EAAGuS,gBAChD2Q,EAAQ1S,oBAAoBT,EAAOG,EAAS5B,GAEhDtO,EAAGuS,qBAAkBvF,OAEFA,IAAnBhN,EAAGmjB,aAA8BnjB,EAAGsT,aAAa,eACjDtT,EAAGmjB,iBAAcnW,GAEhBoW,KAAAA,kBAAkBpjB,EAAI+K,EAAWiF,GACjCqT,KAAAA,uBAAuBrjB,GAAI,EAAM+K,GAG1CgB,eAAegX,EAAQhY,EAAY,UAC1B6X,KAAAA,4BAA4BG,EAAQ/iB,IAEjCA,QAAqBgN,IAArBhN,EAAG6L,gBAAgC7L,EAAG0N,WAAW,KAAKiS,KAAM,OAAO,EAElE2D,KAAAA,cAActjB,EAAI+K,IACxB/K,IACCA,EAAG8iB,MAAQ,IAAIpD,EAAU1f,KAGxBuP,KAAAA,6CAEA0T,KAAAA,6BAA6BF,GAGtCE,6BAA6BjjB,GAErBA,IAAO,KAAK2f,KAAO,KAAKxN,cAAcjD,OAAS,GAG/C7E,sBAAsB,KACX,KAAA,KAAK8H,cAAcjD,OAAS,GAC1BiD,KAAAA,cAAcoR,OAAdpR,KAMrB5C,6CAISC,KAAAA,mBAAmBgU,UAAUxf,IAAIkM,GAC3B,IAAIpR,QAAQ,CAACC,EAASmH,KACzBgK,EAAQnR,EAASmH,MAEtB4S,OAAO,CAAC2K,EAAcC,IACdD,EAAazS,KAAK,IACd0S,EAAQ1S,KAAK2S,IAChBA,OAGT7kB,QAAQC,QAAQ,SAAYuD,MAAMC,IAC7BA,GAAAA,IAAMwD,EAAV,qBAAgC,MAAMxD,IAIrCiN,KAAAA,mBAAqB,GACrBH,KAAAA,8BAA2BrC,EAGpCsW,cAActjB,EAAI+K,GACTsY,KAAAA,uBAAuBrjB,GAAI,EAAO+K,GAG3CqY,kBAAkBpjB,EAAI+K,EAAWiF,IACnBhQ,EAAAA,EAAAA,WAAAA,EAAI,MAAMqL,QAAQ,EAAGzH,KAAAA,EAAMvB,MAAAA,EAAO8C,UAAAA,EAAWpD,WAAAA,MAC3C6B,OAAAA,GACC,IAAA,MACgB,EAAA,EAAA,kBAAA,KAAM5D,EAAIqC,EAAO8C,EAAWpD,EAAYgJ,EAAWiF,GACpE,MAEC,IAAA,SACqB,EAAA,EAAA,uBAAA,KAAMhQ,EAAImF,EAAWpD,EAAYgJ,MAQvEsY,uBAAuBrjB,EAAI8K,GAAgB,EAAOC,GAC1C1E,IAAAA,GAAQ,EAAUrG,EAAAA,WAAAA,EAAI,MAC1BqG,EAAMgF,QAAQ,EAAGzH,KAAAA,EAAMvB,MAAAA,EAAO8C,UAAAA,EAAWpD,WAAAA,MAC7B6B,OAAAA,GACC,IAAA,SAC+B,EAAA,EAAA,iCAAA,KAAM5D,EAAI,QAAS+B,EAAYgJ,EAAWnH,EAAMuB,GAChF,MAEC,IAAA,OAEGnF,GAA6B,aAA7BA,EAAGE,QAAQC,eAA0C,QAAVkC,EAAiB,QAEhC,EAAA,EAAA,iCAAA,KAAMrC,EAAIqC,EAAON,EAAYgJ,EAAWnH,EAAMuB,GAC9E,MAEC,IAAA,OACGwJ,IAAAA,EAAS,KAAKpF,yBAAyBvJ,EAAI+B,EAAYgJ,IAEvC/K,EAAAA,EAAAA,qBAAAA,EAAI2O,EAAQ5M,GAChC,MAEC,IAAA,QACmB,EAAA,EAAA,qBAAA,KAAM/B,EAAI+B,EAAYgJ,GAC1C,MAEC,IAAA,OACG4D,EAAS,KAAKpF,yBAAyBvJ,EAAI+B,EAAYgJ,IAEvC,EAAA,EAAA,qBAAA,KAAM/K,EAAI2O,EAAQxJ,EAAW2F,GACjD,MAEC,IAAA,KAGGzE,GAAAA,EAAMK,KAAKnC,GAAgB,QAAXA,EAAEX,MAAiB,OAEnC+K,EAAS,KAAKpF,yBAAyBvJ,EAAI+B,EAAYgJ,IAEzC,EAAA,EAAA,mBAAA,KAAM/K,EAAI2O,EAAQ7D,EAAeC,GACnD,MAEC,IAAA,OACkB,EAAA,EAAA,oBAAA,KAAM/K,EAAI+B,EAAY+I,EAAeC,GACxD,MAEC,IAAA,QACD/K,EAAGkO,gBAAgB,gBAcnC3E,yBAAyBvJ,EAAI+B,EAAYgJ,EAAY,UAC7CyH,IAAAA,EAAO,KACPoR,EAAU7Y,IACV8Y,OAAsB7W,IAAZ4W,QAA2C5W,IAAlB4W,EAAQE,MAAsBF,EAAQE,MAAQ9jB,EAC9E,OAAA,EAAUA,EAAAA,WAAAA,EAAI+B,EAAY,KAAKqC,MAAO,CACzC0f,MAAO9jB,KACJ4jB,EACHG,UAAW,KAAKC,oBAAoBhkB,GACpCikB,OAAQ,IAAezR,EAAK0R,aAAaL,KAIjDpR,0BAA0BzS,EAAI+B,EAAYgJ,EAAY,UAC9CyH,IAAAA,EAAO,KACPoR,EAAU7Y,IACV8Y,OAAsB7W,IAAZ4W,QAA2C5W,IAAlB4W,EAAQE,MAAsBF,EAAQE,MAAQ9jB,EAC9E,OAAA,EAAkBA,EAAAA,mBAAAA,EAAI+B,EAAY,KAAKqC,MAAO,CACjD0f,MAAO9jB,KACJ4jB,EACHG,UAAW,KAAKC,oBAAoBhkB,GACpCikB,OAAQ,IAAezR,EAAK0R,aAAaL,KAIjDG,oBAAoBhkB,GACT,MAAA,CAAC+P,EAAOgB,EAAS,MACpB/Q,EAAGmkB,cAAc,IAAI/R,YAAYrC,EAAO,CACpCgB,OAAAA,EACAqT,SAAS,MAKrBzC,mCACU0C,MAAAA,EAAa,KAAK1E,IAQlB2E,EAAW,IAAIC,iBAAkBC,IAC9B,IAAA,IAAIjgB,EAAI,EAAGA,EAAIigB,EAAUtV,OAAQ3K,IAAK,CAEjCkgB,MAAAA,EAAyBD,EAAUjgB,GAAG6L,OAAOsU,QAAQ,cAErDD,GAA0BA,EAAuB/W,WAAW,KAAKiS,OAE7C,eAAtB6E,EAAUjgB,GAAGX,MAAyB4gB,EAAUjgB,GAAGogB,cAanDH,EAAUjgB,GAAGqgB,WAAW1V,OAAS,GACjCsV,EAAUjgB,GAAGqgB,WAAWvZ,QAAQpK,IACN,IAAlBA,EAAK4jB,UAAkB5jB,EAAK4O,mBAC3B5O,EAAKqS,aAAa,aAAerS,EAAKmN,aAAa,cAAgB,KAAK6P,UAAahd,EAAKqS,aAAa,oBASvG0P,KAAAA,kBAAkB/hB,EAAM,QAAW,SAOjDqjB,OADPA,EAASQ,QAAQT,EA5CO,CACpBU,WAAW,EACXjhB,YAAY,EACZkhB,SAAS,IA0CNV,EAGXlD,eACQ5O,IAAAA,EAAO,KAsBJ,OAAA,IAAIqI,MApBE,GAoBY,CACrBtF,IAAI4D,EAAQsI,GACJA,MAAa,mBAAbA,IAMJjP,EAAKoQ,4BAA4BpQ,EAAKmN,IAAK3f,IACnCA,EAAGsT,aAAa,YAActT,EAAGoO,aAAa,aAAeqT,IAC7DwD,EAAMjlB,KAIPilB,GAVHA,IAAAA,KAchBf,aAAalkB,GACLwS,IAAAA,EAAO,KACPxS,GAAAA,IAAOyQ,OACA,MAAA,GAEPyU,IAAAA,EAAW,KACXllB,GAAAA,EAAGsT,aAAa,aAChB4R,EAAWllB,MACR,CACCmlB,IAAAA,EAAKnlB,EAAG0kB,QAAQ,eAChBS,GAAO,OAAPA,EAAa,CACTC,IAAAA,EAAKD,EAAGT,QAAQ,cACT,OAAPU,GAAeA,EAAGhX,aAAa,cAAgBoE,EAAKyL,WACpDiH,EAAWC,IAInBD,GAAa,OAAbA,EAAmB,MACUlY,IAAzBkY,EAAS/B,cACT+B,EAAS/B,YAAc,KAAK5Z,yBAAyB2b,EAAUA,EAAS9W,aAAa,eAGrF,IAAA,SAAEqH,EAAF,KAAYsF,IAAS,EAAKmK,EAAAA,MAAAA,EAAS/B,YAAa,CAAC/S,EAAQ1I,KACzD8K,EAAK0N,eAEFnF,OAAAA,EAEJ,MAAA,IAhnBgB,QAAA,QAAA;;ACsI/B,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EApKA,IAAA,EAAA,EAAA,QAAA,gBACA,EAAA,QAAA,WAmKA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAjKA,MAAMsK,UAAqB3F,EAA3B,QAIExc,YAAYoiB,GACJA,MAAAA,EAAaC,KACdvH,KAAAA,YAAcsH,EAAatH,YAC3BsH,KAAAA,aAAeA,EACfrH,KAAAA,SAAWqH,EAAarH,SAK/B+B,MAAMwF,GACExF,MAAAA,MACJ,KAAKsF,aAAatH,YAClB,KAAKsH,aAAarH,SAClB,KAAKqH,aAAazF,MAClB,KAAKyF,aAAaxF,aACQ9S,IAAzBwY,GACiC,OAA7BA,EAAqBC,KAErBD,EAAqBvH,WAAa,KAAKA,SACxCuH,EAAqBC,SACrBzY,GAER4U,UACQA,MAAAA,WAGKyD,IAAAA,EAAAA,EAmIf,QAAA,QAAA;;AC1FC,aAtED,SAASK,EAAiB1lB,GACpBA,OAAAA,EAAGsT,aAAa,YACXtT,EAAGoO,aAAa,YACdpO,EAAGsT,aAAa,mBAClBtT,EAAGoO,aAAa,mBAEhB,KAIX,SAASuX,EAAiB3lB,EAAIgB,EAAU4kB,EAAwBC,QAC3C7Y,IAAf6Y,IACFA,EAAa7lB,EAAGoO,aAAa,aAE3B0X,IAAAA,EAAoBJ,EAAiB1lB,GACrC8lB,GAAsB,OAAtBA,GAA8BA,IAAsBD,EAClDD,MAAAA,GACFA,EAAuB5lB,EAAI8lB,QAOtB9lB,SAJUgN,IAAbhM,GACFA,EAAShB,GAEXA,EAAKA,EAAGkB,kBACDlB,GACL2lB,EAAiB3lB,EAAIgB,EAAU4kB,EAAwBC,GACvD7lB,EAAKA,EAAGmB,mBA4Cb,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA,EAAA,QAAA,SAAA,EAAA,QAAA,UAAA,EAAA,QAAA,mBAAA,EAvCD,IAAI6B,EAAgBf,OAAOgB,eAAe,oBAAuBC,YAGjE,SAAS6iB,EAASC,GACZC,IAAAA,EAAW5jB,EAAOqF,EAElB,GAAoB,iBAAbse,GAAsC,OAAbA,EAC3BA,OAAAA,EAMJte,IAAAA,KAFLue,EAAY5mB,MAAMoL,QAAQub,GAAY,GAAK,GAE/BA,EACV3jB,EAAQ2jB,EAASte,GAGjBue,EAAUve,GAAOqe,EAAS1jB,GAGrB4jB,OAAAA,EAKT,SAASC,EAAU3iB,GACX4iB,IAAAA,EAAc,KACdnnB,GAAAA,SAASonB,QAA8B,KAApBpnB,SAASonB,OAAe,CACrCC,MAAAA,EAAUrnB,SAASonB,OAAOxgB,MAAM,KACjC,IAAA,IAAIrB,EAAI,EAAGA,EAAI8hB,EAAQnX,OAAQ3K,IAAK,CAC/B6hB,MAAAA,EAASC,EAAQ9hB,GAAGyE,OAEtBod,GAAAA,EAAOE,UAAU,EAAG/iB,EAAK2L,OAAS,KAAQ3L,EAAO,IAAM,CACvD4iB,EAAcI,mBAAmBH,EAAOE,UAAU/iB,EAAK2L,OAAS,IAChE,QAILiX,OAAAA,EACV,QAAA,cAAA;;ACZA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EA9DD,IAAIK,EAAyB,GAEd,SAASC,EAAWC,EAAUC,GACrCC,IACAtjB,EACA+B,EACAwhB,EACAC,EAJAF,EAAcD,EAAO7iB,WAQrB6iB,GAAAA,EAAO9B,WAAa2B,GAA0BE,EAAS7B,WAAa2B,EAApEG,CAKC,IAAA,IAAIpiB,EAAIqiB,EAAY1X,OAAS,EAAG3K,GAAK,EAAGA,IAEzCc,GADA/B,EAAOsjB,EAAYriB,IACHhB,KAChBsjB,EAAmBvjB,EAAKyjB,aACxBD,EAAYxjB,EAAKjB,MAEbwkB,GACAxhB,EAAW/B,EAAK0jB,WAAa3hB,EACjBqhB,EAASO,eAAeJ,EAAkBxhB,KAEpCyhB,IACM,UAAhBxjB,EAAK4jB,SACL7hB,EAAW/B,EAAKC,MAEpBmjB,EAASS,eAAeN,EAAkBxhB,EAAUyhB,KAG5CJ,EAAStY,aAAa/I,KAEhByhB,GACdJ,EAAS5Y,aAAazI,EAAUyhB,GASvC,IAFDM,IAAAA,EAAgBV,EAAS5iB,WAEpBujB,EAAID,EAAclY,OAAS,EAAGmY,GAAK,EAAGA,IAE3ChiB,GADA/B,EAAO8jB,EAAcC,IACL9jB,MAChBsjB,EAAmBvjB,EAAKyjB,eAGpB1hB,EAAW/B,EAAK0jB,WAAa3hB,EAExBshB,EAAOW,eAAeT,EAAkBxhB,IACzCqhB,EAASa,kBAAkBV,EAAkBxhB,IAG5CshB,EAAOrT,aAAajO,IACrBqhB,EAASxY,gBAAgB7I;;ACsDxC,aAhHD,IAAImiB,EAgHH,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,UAAA,EAAA,QAAA,iBAAA,EAAA,QAAA,gBAAA,EAAA,QAAA,aAAA,EAAA,QAAA,SAAA,EA/GD,IAAIC,EAAW,+BAEJC,EAA0B,oBAAb1oB,cAA2BgO,EAAYhO,SA6G9D,QAAA,IAAA,EA5GD,IAAI2oB,IAAyBD,GAAO,YAAaA,EAAIE,cAAc,YAC/DC,IAAsBH,GAAOA,EAAII,aAAe,6BAA8BJ,EAAII,cAEtF,SAASC,EAA2BC,GAC5BC,IAAAA,EAAWP,EAAIE,cAAc,YAE1BK,OADPA,EAASnZ,UAAYkZ,EACdC,EAAS3nB,QAAQ4nB,WAAW,GAGvC,SAASC,EAAwBH,GAOtBI,OANFZ,IACDA,EAAQE,EAAII,eACNO,WAAWX,EAAIhX,MAGV8W,EAAMc,yBAAyBN,GAC9BE,WAAW,GAG/B,SAASK,EAAuBP,GACxBI,IAAAA,EAAWV,EAAIE,cAAc,QAE1BQ,OADPA,EAAStZ,UAAYkZ,EACdI,EAASF,WAAW,GAWxB,SAASM,EAAUR,GAElBL,OADJK,EAAMA,EAAIhf,OACN2e,EAIKI,EAA2BC,GACzBH,EACFM,EAAwBH,GAG1BO,EAAuBP,GAa3B,SAASS,EAAiBC,EAAQC,GACjCC,IAEAC,EAAeC,EAFfF,EAAeF,EAAOK,SACtBC,EAAaL,EAAKI,SAGlBH,OAAAA,IAAiBI,IAIrBH,EAAgBD,EAAaK,WAAW,GACxCH,EAAcE,EAAWC,WAAW,GAMhCJ,GAAiB,IAAMC,GAAe,GAC/BF,IAAiBI,EAAWloB,cAC5BgoB,GAAe,IAAMD,GAAiB,IACtCG,IAAeJ,EAAa9nB,eAepC,SAASooB,EAAgB3lB,EAAMwjB,GAC3B,OAACA,GAAgBA,IAAiBU,EAErCC,EAAIwB,gBAAgBnC,EAAcxjB,GADlCmkB,EAAIE,cAAcrkB,GAOnB,SAAS4lB,EAAaT,EAAQC,GAE1BS,IADHA,IAAAA,EAAWV,EAAOW,WACfD,GAAU,CACTE,IAAAA,EAAYF,EAAShc,YACzBub,EAAKY,YAAYH,GACjBA,EAAWE,EAERX,OAAAA;;ACpGI,aAXf,SAASa,EAAoBd,EAAQC,EAAMplB,GACnCmlB,EAAOnlB,KAAUolB,EAAKplB,KACtBmlB,EAAOnlB,GAAQolB,EAAKplB,GAChBmlB,EAAOnlB,GACPmlB,EAAO5a,aAAavK,EAAM,IAE1BmlB,EAAOxa,gBAAgB3K,IAKpB,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAAA,IAAA,EAAA,CACXkmB,OAAQ,SAASf,EAAQC,GACjBe,IAAAA,EAAahB,EAAOgB,WACpBA,GAAAA,EAAY,CACRC,IAAAA,EAAaD,EAAWX,SAASjoB,cAClB,aAAf6oB,IAEAA,GADAD,EAAaA,EAAWA,aACGA,EAAWX,SAASjoB,eAEhC,WAAf6oB,GAA4BD,EAAWpW,aAAa,cAChDoV,EAAOpV,aAAa,cAAgBqV,EAAKna,WAIzCka,EAAO5a,aAAa,WAAY,YAChC4a,EAAOxa,gBAAgB,aAK3Bwb,EAAWE,eAAiB,GAGpCJ,EAAoBd,EAAQC,EAAM,aAQtCkB,MAAO,SAASnB,EAAQC,GACpBa,EAAoBd,EAAQC,EAAM,WAClCa,EAAoBd,EAAQC,EAAM,YAE9BD,EAAOrmB,QAAUsmB,EAAKtmB,QACtBqmB,EAAOrmB,MAAQsmB,EAAKtmB,OAGnBsmB,EAAKrV,aAAa,UACnBoV,EAAOxa,gBAAgB,UAI/B4b,SAAU,SAASpB,EAAQC,GACnBnV,IAAAA,EAAWmV,EAAKtmB,MAChBqmB,EAAOrmB,QAAUmR,IACjBkV,EAAOrmB,MAAQmR,GAGf6V,IAAAA,EAAaX,EAAOW,WACpBA,GAAAA,EAAY,CAGRU,IAAAA,EAAWV,EAAWW,UAEtBD,GAAAA,GAAYvW,IAAcA,GAAYuW,GAAYrB,EAAOuB,YACzD,OAGJZ,EAAWW,UAAYxW,IAG/B0W,OAAQ,SAASxB,EAAQC,GACjB,IAACA,EAAKrV,aAAa,YAAa,CAU1B8V,IATFQ,IAOAO,EACApB,EARAa,GAAiB,EACjBrlB,EAAI,EAKJ6kB,EAAWV,EAAOW,WAGhBD,GAEEL,GAAa,cADjBA,EAAWK,EAASL,UAAYK,EAASL,SAASjoB,eAG9CsoB,GADAe,EAAWf,GACSC,eACjB,CACCN,GAAa,WAAbA,EAAuB,CACnBK,GAAAA,EAAS9V,aAAa,YAAa,CACnCsW,EAAgBrlB,EAChB,MAEJA,MAEJ6kB,EAAWA,EAAShc,cACH+c,IACbf,EAAWe,EAAS/c,YACpB+c,EAAW,MAKvBzB,EAAOkB,cAAgBA,KA/FpB,QAAA,QAAA;;;ACsgBf,IAAA,EAAA,QAAA,WAvfA,SAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,mCAAA,KAAA,UAAA,IAKA,SAAA,EAAA,EAAA,GAMA,IALA,IAIA,EAJA,EAAA,GACA,EAAA,EACA,GAAA,EACA,EAAA,EAEA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,CACA,GAAA,EAAA,EAAA,OACA,EAAA,EAAA,WAAA,OACA,CAAA,GAAA,KAAA,EACA,MAEA,EAAA,GACA,GAAA,KAAA,EAAA,CACA,GAAA,IAAA,EAAA,GAAA,IAAA,QAEA,GAAA,IAAA,EAAA,GAAA,IAAA,EAAA,CACA,GAAA,EAAA,OAAA,GAAA,IAAA,GAAA,KAAA,EAAA,WAAA,EAAA,OAAA,IAAA,KAAA,EAAA,WAAA,EAAA,OAAA,GACA,GAAA,EAAA,OAAA,EAAA,CACA,IAAA,EAAA,EAAA,YAAA,KACA,GAAA,IAAA,EAAA,OAAA,EAAA,EACA,IAAA,GACA,EAAA,GACA,EAAA,GAGA,GADA,EAAA,EAAA,MAAA,EAAA,IACA,OAAA,EAAA,EAAA,YAAA,KAEA,EAAA,EACA,EAAA,EACA,eAEA,GAAA,IAAA,EAAA,QAAA,IAAA,EAAA,OAAA,CACA,EAAA,GACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,SAGA,IACA,EAAA,OAAA,EACA,GAAA,MAEA,EAAA,KACA,EAAA,QAGA,EAAA,OAAA,EACA,GAAA,IAAA,EAAA,MAAA,EAAA,EAAA,GAEA,EAAA,EAAA,MAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAEA,EAAA,EACA,EAAA,OACA,KAAA,IAAA,IAAA,IACA,EAEA,GAAA,EAGA,OAAA,EAGA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,KAAA,EAAA,KACA,EAAA,EAAA,OAAA,EAAA,MAAA,KAAA,EAAA,KAAA,IACA,OAAA,EAGA,IAAA,EAAA,KACA,EAAA,EAEA,EAAA,EAAA,EALA,EAQA,IAAA,EAAA,CAEA,QAAA,WAKA,IAJA,IAEA,EAFA,EAAA,GACA,GAAA,EAGA,EAAA,UAAA,OAAA,EAAA,IAAA,IAAA,EAAA,IAAA,CACA,IAAA,EACA,GAAA,EACA,EAAA,UAAA,SAEA,IAAA,IACA,EAAA,EAAA,OACA,EAAA,GAGA,EAAA,GAGA,IAAA,EAAA,SAIA,EAAA,EAAA,IAAA,EACA,EAAA,KAAA,EAAA,WAAA,IASA,OAFA,EAAA,EAAA,GAAA,GAEA,EACA,EAAA,OAAA,EACA,IAAA,EAEA,IACA,EAAA,OAAA,EACA,EAEA,KAIA,UAAA,SAAA,GAGA,GAFA,EAAA,GAEA,IAAA,EAAA,OAAA,MAAA,IAEA,IAAA,EAAA,KAAA,EAAA,WAAA,GACA,EAAA,KAAA,EAAA,WAAA,EAAA,OAAA,GAQA,OAHA,KAFA,EAAA,EAAA,GAAA,IAEA,QAAA,IAAA,EAAA,KACA,EAAA,OAAA,GAAA,IAAA,GAAA,KAEA,EAAA,IAAA,EACA,GAGA,WAAA,SAAA,GAEA,OADA,EAAA,GACA,EAAA,OAAA,GAAA,KAAA,EAAA,WAAA,IAGA,KAAA,WACA,GAAA,IAAA,UAAA,OACA,MAAA,IAEA,IADA,IAAA,EACA,EAAA,EAAA,EAAA,UAAA,SAAA,EAAA,CACA,IAAA,EAAA,UAAA,GACA,EAAA,GACA,EAAA,OAAA,SACA,IAAA,EACA,EAAA,EAEA,GAAA,IAAA,GAGA,YAAA,IAAA,EACA,IACA,EAAA,UAAA,IAGA,SAAA,SAAA,EAAA,GAIA,GAHA,EAAA,GACA,EAAA,GAEA,IAAA,EAAA,MAAA,GAKA,IAHA,EAAA,EAAA,QAAA,OACA,EAAA,EAAA,QAAA,IAEA,MAAA,GAIA,IADA,IAAA,EAAA,EACA,EAAA,EAAA,QACA,KAAA,EAAA,WAAA,KADA,GASA,IALA,IAAA,EAAA,EAAA,OACA,EAAA,EAAA,EAGA,EAAA,EACA,EAAA,EAAA,QACA,KAAA,EAAA,WAAA,KADA,GAWA,IAPA,IACA,EADA,EAAA,OACA,EAGA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,EACA,EAAA,EACA,GAAA,IAAA,EAAA,CACA,GAAA,IAAA,EAAA,CACA,GAAA,EAAA,EAAA,CACA,GAAA,KAAA,EAAA,WAAA,EAAA,GAGA,OAAA,EAAA,MAAA,EAAA,EAAA,GACA,GAAA,IAAA,EAGA,OAAA,EAAA,MAAA,EAAA,QAEA,EAAA,IACA,KAAA,EAAA,WAAA,EAAA,GAGA,EAAA,EACA,IAAA,IAGA,EAAA,IAGA,MAEA,IAAA,EAAA,EAAA,WAAA,EAAA,GAEA,GAAA,IADA,EAAA,WAAA,EAAA,GAEA,MACA,KAAA,IACA,EAAA,GAGA,IAAA,EAAA,GAGA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EACA,IAAA,GAAA,KAAA,EAAA,WAAA,KACA,IAAA,EAAA,OACA,GAAA,KAEA,GAAA,OAMA,OAAA,EAAA,OAAA,EACA,EAAA,EAAA,MAAA,EAAA,IAEA,GAAA,EACA,KAAA,EAAA,WAAA,MACA,EACA,EAAA,MAAA,KAIA,UAAA,SAAA,GACA,OAAA,GAGA,QAAA,SAAA,GAEA,GADA,EAAA,GACA,IAAA,EAAA,OAAA,MAAA,IAKA,IAJA,IAAA,EAAA,EAAA,WAAA,GACA,EAAA,KAAA,EACA,GAAA,EACA,GAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EAEA,GAAA,MADA,EAAA,EAAA,WAAA,KAEA,IAAA,EAAA,CACA,EAAA,EACA,YAIA,GAAA,EAIA,OAAA,IAAA,EAAA,EAAA,IAAA,IACA,GAAA,IAAA,EAAA,KACA,EAAA,MAAA,EAAA,IAGA,SAAA,SAAA,EAAA,GACA,QAAA,IAAA,GAAA,iBAAA,EAAA,MAAA,IAAA,UAAA,mCACA,EAAA,GAEA,IAGA,EAHA,EAAA,EACA,GAAA,EACA,GAAA,EAGA,QAAA,IAAA,GAAA,EAAA,OAAA,GAAA,EAAA,QAAA,EAAA,OAAA,CACA,GAAA,EAAA,SAAA,EAAA,QAAA,IAAA,EAAA,MAAA,GACA,IAAA,EAAA,EAAA,OAAA,EACA,GAAA,EACA,IAAA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,WAAA,GACA,GAAA,KAAA,GAGA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,YAGA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAEA,GAAA,IAEA,IAAA,EAAA,WAAA,IACA,KAAA,IAGA,EAAA,IAKA,GAAA,EACA,EAAA,IAOA,OADA,IAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,QACA,EAAA,MAAA,EAAA,GAEA,IAAA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EACA,GAAA,KAAA,EAAA,WAAA,IAGA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,YAEA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAIA,OAAA,IAAA,EAAA,GACA,EAAA,MAAA,EAAA,IAIA,QAAA,SAAA,GACA,EAAA,GAQA,IAPA,IAAA,GAAA,EACA,EAAA,EACA,GAAA,EACA,GAAA,EAGA,EAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,WAAA,GACA,GAAA,KAAA,GASA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAEA,KAAA,GAEA,IAAA,EACA,EAAA,EACA,IAAA,IACA,EAAA,IACA,IAAA,IAGA,GAAA,QArBA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,OAuBA,OAAA,IAAA,IAAA,IAAA,GAEA,IAAA,GAEA,IAAA,GAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EACA,GAEA,EAAA,MAAA,EAAA,IAGA,OAAA,SAAA,GACA,GAAA,OAAA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,0EAAA,GAEA,OAAA,EAAA,IAAA,IAGA,MAAA,SAAA,GACA,EAAA,GAEA,IAAA,EAAA,CAAA,KAAA,GAAA,IAAA,GAAA,KAAA,GAAA,IAAA,GAAA,KAAA,IACA,GAAA,IAAA,EAAA,OAAA,OAAA,EACA,IAEA,EAFA,EAAA,EAAA,WAAA,GACA,EAAA,KAAA,EAEA,GACA,EAAA,KAAA,IACA,EAAA,GAEA,EAAA,EAaA,IAXA,IAAA,GAAA,EACA,EAAA,EACA,GAAA,EACA,GAAA,EACA,EAAA,EAAA,OAAA,EAIA,EAAA,EAGA,GAAA,IAAA,EAEA,GAAA,MADA,EAAA,EAAA,WAAA,KAUA,IAAA,IAGA,GAAA,EACA,EAAA,EAAA,GAEA,KAAA,GAEA,IAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,IACA,IAAA,IAGA,GAAA,QAlBA,IAAA,EAAA,CACA,EAAA,EAAA,EACA,MAyCA,OArBA,IAAA,IAAA,IAAA,GAEA,IAAA,GAEA,IAAA,GAAA,IAAA,EAAA,GAAA,IAAA,EAAA,GACA,IAAA,IACA,EAAA,KAAA,EAAA,KAAA,IAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAAA,EAAA,MAAA,EAAA,KAGA,IAAA,GAAA,GACA,EAAA,KAAA,EAAA,MAAA,EAAA,GACA,EAAA,KAAA,EAAA,MAAA,EAAA,KAEA,EAAA,KAAA,EAAA,MAAA,EAAA,GACA,EAAA,KAAA,EAAA,MAAA,EAAA,IAEA,EAAA,IAAA,EAAA,MAAA,EAAA,IAGA,EAAA,EAAA,EAAA,IAAA,EAAA,MAAA,EAAA,EAAA,GAAA,IAAA,EAAA,IAAA,KAEA,GAGA,IAAA,IACA,UAAA,IACA,MAAA,KACA,MAAA,MAGA,EAAA,MAAA,EAEA,OAAA,QAAA;;AChhBA,aAofC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EA9eD,IAAA,EAAA,QAAA,UACA,EAAA,EAAA,QAAA,wBACA,EAAA,QAAA,mBA4eC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA1eD,IAAIQ,EAAe,EACf5D,EAAyB,GACzB6D,EAAY,EACZC,EAAe,EAEnB,SAAS5N,KAET,SAAS6N,EAAkBtpB,GACrBA,GAAAA,EACQA,OAAAA,EAAKmN,cAAgBnN,EAAKmN,aAAa,OAAUnN,EAAKqR,GAIrD,SAASkY,EAAgB/D,GAE7B,OAAA,SAAkBC,EAAUC,EAAQrY,GAKnC,GAJCA,IACDA,EAAU,IAGQ,iBAAXqY,EACHD,GAAsB,cAAtBA,EAASqC,UAAkD,SAAtBrC,EAASqC,UAA6C,SAAtBrC,EAASqC,SAAqB,CAC/F0B,IAAAA,EAAa9D,GACjBA,EAASe,EAAIE,IAAAA,cAAc,SACpB9Y,UAAY2b,OAEnB9D,GAAS,EAAUA,EAAAA,WAAAA,QAEhBA,EAAO9B,WAAa2B,IAC7BG,EAASA,EAAOzlB,mBAGdwpB,IAAAA,EAAapc,EAAQoc,YAAcH,EACnCI,EAAoBrc,EAAQqc,mBAAqBjO,EACjDkO,EAActc,EAAQsc,aAAelO,EACrCmO,EAAoBvc,EAAQuc,mBAAqBnO,EACjDoO,EAAcxc,EAAQwc,aAAepO,EACrCqO,EAAwBzc,EAAQyc,uBAAyBrO,EACzDsO,EAAkB1c,EAAQ0c,iBAAmBtO,EAC7CuO,EAA4B3c,EAAQ2c,2BAA6BvO,EACjEwO,GAAwC,IAAzB5c,EAAQ4c,aAGvBC,EAAkBlpB,OAAO6R,OAAO,MAChCsX,EAAmB,GAEdC,SAAAA,EAAgB3jB,GACrB0jB,EAAiB3b,KAAK/H,GAqCjB4jB,SAAAA,EAAWrqB,EAAMyoB,EAAY6B,IACE,IAAhCR,EAAsB9pB,KAItByoB,GACAA,EAAW8B,YAAYvqB,GAG3B+pB,EAAgB/pB,GA3CXwqB,SAAAA,EAAwBxqB,EAAMsqB,GAC/BtqB,GAAAA,EAAK4jB,WAAauF,EAEXhB,IADHA,IAAAA,EAAWnoB,EAAKooB,WACbD,GAAU,CAET1hB,IAAAA,OAAMsF,EAENue,IAAmB7jB,EAAMgjB,EAAWtB,IAGpCiC,EAAgB3jB,IAKhBsjB,EAAgB5B,GACZA,EAASC,YACToC,EAAwBrC,EAAUmC,IAI1CnC,EAAWA,EAAShc,aAuB5Bqe,CAAwBxqB,EAAMsqB,IAkDzBG,SAAAA,EAAgB1rB,GACrB4qB,EAAY5qB,GAGLopB,IADHA,IAAAA,EAAWppB,EAAGqpB,WACXD,GAAU,CACThc,IAAAA,EAAcgc,EAAShc,YAEvB1F,EAAMgjB,EAAWtB,GACjB1hB,GAAAA,EAAK,CACDikB,IAAAA,EAAkBR,EAAgBzjB,GAGlCikB,IAAmB,EAAiBvC,EAAAA,kBAAAA,EAAUuC,IAC9CvC,EAASM,WAAWkC,aAAaD,EAAiBvC,GAClDyC,EAAQF,EAAiBvC,IAE3BsC,EAAgBtC,QAKpBsC,EAAgBtC,GAGlBA,EAAWhc,GAuBVye,SAAAA,EAAQnD,EAAQC,EAAMuC,GACvBY,IAAAA,EAAUpB,EAAW/B,GAQrB,GANAmD,UAGOX,EAAgBW,IAGtBZ,EAAc,CAEXL,IAAoC,IAApCA,EAAkBnC,EAAQC,GAC1B,OAQAsC,GAJJxE,EAAWiC,EAAQC,GAEnBmC,EAAYpC,IAEoC,IAA5CuC,EAA0BvC,EAAQC,GAClC,OAIgB,aAApBD,EAAOK,SAONgD,SAAcrD,EAAQC,GACvBqD,IAEAC,EACAC,EAEAC,EACAC,EACAC,EAPAL,EAAiBrD,EAAKU,WACtBiD,EAAmB5D,EAAOW,WAS9BkD,EAAO,KAAOP,GAAgB,CAKnBM,IAJPF,EAAgBJ,EAAe5e,YAC/B6e,EAAevB,EAAWsB,GAGnBM,GAAkB,CAGjBN,GAFJG,EAAkBG,EAAiBlf,YAE/B4e,EAAete,YAAcse,EAAete,WAAW4e,GAAmB,CAC1EN,EAAiBI,EACjBE,EAAmBH,EACVI,SAAAA,EAGbL,EAAiBxB,EAAW4B,GAExBE,IAAAA,EAAkBF,EAAiBzH,SAGnC4H,OAAezf,EA0Ffyf,GAxFAD,IAAoBR,EAAenH,WAC/B2H,IAAoBpC,GAGhB6B,EAGIA,IAAiBC,KAIZG,EAAiBlB,EAAgBc,IAC9BE,IAAoBE,EAMpBI,GAAe,GASf/D,EAAO3b,aAAasf,EAAgBC,GAIhCJ,EAGAb,EAAgBa,GAIhBZ,EAAWgB,EAAkB5D,GAAQ,GAGzC4D,EAAmBD,GAKvBI,GAAe,GAGhBP,IAEPO,GAAe,IAGnBA,GAAgC,IAAjBA,IAA0B,EAAiBH,EAAAA,kBAAAA,EAAkBN,OAQlEA,EAAeU,YAAYJ,IAC1BN,EAAe7qB,oBACf6qB,EAAe7qB,mBAAmBurB,YAAYJ,GAEjDG,GAAe,EAMfZ,EAAQS,EAAkBN,KAI3BQ,IAAoBnC,GAAamC,GAAmBlC,IAE3DmC,GAAe,EAGXH,EAAiBtC,YAAcgC,EAAehC,YAC9CsC,EAAiBtC,UAAYgC,EAAehC,aAMpDyC,EAAc,CAGdT,EAAiBI,EACjBE,EAAmBH,EACVI,SAAAA,EASTP,GAAAA,EAAe7qB,oBAAsB6qB,EAAe7qB,mBAAmBurB,YAAYJ,GAAmB,CAChGK,MAAAA,EAAgBX,EAAeY,WAAU,GAC/ClE,EAAO3b,aAAa4f,EAAeL,GACnCZ,EAAgBiB,GAChBX,EAAiBA,EAAe7qB,mBAAmBiM,YACnDkf,EAAmBH,EACVI,SAAAA,EAQLL,EAGAb,EAAgBa,GAIhBZ,EAAWgB,EAAkB5D,GAAQ,GAG7C4D,EAAmBH,EAOnBF,GAAAA,IAAiBI,EAAiBlB,EAAgBc,MAAkB,EAAiBI,EAAAA,kBAAAA,EAAgBL,GACrGtD,EAAOa,YAAY8C,GAEnBR,EAAQQ,EAAgBL,OACrB,CACCa,IAAAA,EAA0BlC,EAAkBqB,IAChB,IAA5Ba,IACIA,IACAb,EAAiBa,GAGjBb,EAAec,YACfd,EAAiBA,EAAec,UAAUpE,EAAOqE,eAAiBrF,EAAjD,MAErBgB,EAAOa,YAAYyC,GACnBN,EAAgBM,IAIxBA,EAAiBI,EACjBE,EAAmBH,GA5OlBa,SAActE,EAAQ4D,EAAkBJ,GAItCI,KAAAA,GAAkB,CACjBH,IAAAA,EAAkBG,EAAiBlf,aAClC8e,EAAiBxB,EAAW4B,IAG7BjB,EAAgBa,GAIhBZ,EAAWgB,EAAkB5D,GAAQ,GAEzC4D,EAAmBH,GAgOvBa,CAActE,EAAQ4D,EAAkBJ,GAEpCe,IAAAA,EAAmBC,EAAkBxE,QAAAA,EAAOK,UAC5CkE,GACAA,EAAiBvE,EAAQC,GAtM3BoD,CAAcrD,EAAQC,GAEJmB,EAAAA,QAAAA,SAASpB,EAAQC,IA9FhCwE,SAAAA,EAAUlsB,GACXA,GAAAA,EAAK4jB,WAAauF,GAAgBnpB,EAAK4jB,WAAa2B,EAE7C4C,IADHA,IAAAA,EAAWnoB,EAAKooB,WACbD,GAAU,CACT1hB,IAAAA,EAAMgjB,EAAWtB,GACjB1hB,IACAyjB,EAAgBzjB,GAAO0hB,GAI3B+D,EAAU/D,GAEVA,EAAWA,EAAShc,aAKhC+f,CAAUzG,GAqRN0G,IAAAA,EAAc1G,EACd2G,EAAkBD,EAAYvI,SAC9ByI,EAAa3G,EAAO9B,SAEpB,IAACqG,EAGGmC,GAAAA,IAAoBjD,EAChBkD,IAAelD,GACV,EAAiB1D,EAAAA,kBAAAA,EAAUC,KAC5BqE,EAAgBtE,GAChB0G,GAAc,EAAa1G,EAAAA,cAAAA,GAAU,EAAgBC,EAAAA,iBAAAA,EAAOoC,SAAUpC,EAAOI,gBAIjFqG,EAAczG,OAEf,GAAI0G,IAAoBhD,GAAagD,IAAoB/C,EAAc,CACtEgD,GAAAA,IAAeD,EAKRD,OAJHA,EAAYpD,YAAcrD,EAAOqD,YACjCoD,EAAYpD,UAAYrD,EAAOqD,WAG5BoD,EAGPA,EAAczG,EAKtByG,GAAAA,IAAgBzG,EAGhBqE,EAAgBtE,OACb,CACCC,GAAAA,EAAOjZ,YAAciZ,EAAOjZ,WAAW0f,GACvC,OAUAhC,GAPJS,EAAQuB,EAAazG,EAAQuE,GAOzBE,EACK,IAAA,IAAI7mB,EAAE,EAAGgY,EAAI6O,EAAiBlc,OAAQ3K,EAAEgY,EAAKhY,IAAK,CAC/CgpB,IAAAA,EAAapC,EAAgBC,EAAiB7mB,IAC9CgpB,GACAjC,EAAWiC,EAAYA,EAAW7D,YAAY,IAkBvD0D,OAZFlC,GAAgBkC,IAAgB1G,GAAYA,EAASgD,aAClD0D,EAAYN,YACZM,EAAcA,EAAYN,UAAUpG,EAASqG,eAAiBrF,EAAhD,MAOlBhB,EAASgD,WAAWkC,aAAawB,EAAa1G,IAG3C0G;;AC7eAI,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EALf,IAAA,EAAA,EAAA,QAAA,iBACA,EAAA,EAAA,QAAA,eAIeA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GAFf,IAAIA,GAAW,EAAgB/G,EAAAA,SAAAA,EAAhB,SAEA+G,EAAAA,EAAAA,QAAAA,QAAAA;;ACyQG,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA,EA9QlB,IAAA,OAAA,uBAAA,QAAA,4BACA,OAAA,QAAA,cACA,QAAA,uBAAA,QAAA,wBACA,QAAA,QAAA,2BACA,KAAA,uBAAA,QAAA,gCA0QkB,SAAA,uBAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GArQlB,MAAMC,aACJvqB,YAAY8a,EAAaC,EAAUlD,EAAMwK,EAAKmI,GACvC1P,KAAAA,YAAcA,EAEdC,KAAAA,SAAWA,EACX0P,KAAAA,eAAiB1P,EAASrY,MAAM,KAAKsJ,OACrC0e,KAAAA,gBAA0C,IAAxB,KAAKD,eAEvB9N,KAAAA,MAAQ9E,EAAK8E,MACbgO,KAAAA,IAAM9S,EAAK8S,IACXC,KAAAA,WAAa/S,EAAK+S,WAClBhO,KAAAA,aAA2B9S,IAAjB+N,EAAK+E,QAAwB/E,EAAK+E,QAAU,GACtDyF,KAAAA,IAAM,KAAKwI,UAAUxI,GACrBmI,KAAAA,WAAaA,EAEbM,KAAAA,aAAe,GACfC,KAAAA,sBAAwB,GACxBxI,KAAAA,IAAM,KAEbzF,MAAMwF,GACC0I,KAAAA,mBACY,OAAb,KAAKzI,MACFA,KAAAA,IAAM,IAAIJ,OAAJ,QAAiB,OAEzBI,KAAAA,IAAIzF,MAAMwF,GACV2I,KAAAA,8CAEPnkB,SAMQub,MAAAA,EAAM,KAAKA,IAGV,OAFF3D,KAAAA,UACL2D,EAAIvb,SACG,KAAKiU,SAId2D,UACmB,OAAb,KAAK6D,KACFA,KAAAA,IAAI7D,UAEN6D,KAAAA,IAAM,KACNF,KAAAA,IAAM,KAEb6I,gBACS,MAAA,CACLnQ,SAAU,KAAKA,SACf4B,MAAO,KAAKA,OAIhBwO,MAAMC,EAAiBrO,GACjB,IAAA,KAAK2N,kBAAmB,KAAKF,WAM/B,GAAA,KAAKA,iBACiB1gB,IAAtBiT,GACAA,EAAkBsF,IAAI7X,WAAW,KAAK6X,MACtCtjB,OAAOY,KAAKyrB,EAAgBN,cAAcruB,SAAS,KAAKse,UAGnDqQ,EAAgBN,aAAa,KAAK/P,UAAUvQ,WAAW,KAAK6X,OAE/D+I,EAAgBN,aAAa,KAAK/P,UAAUsQ,YAAY,KAAKhJ,KAC7D+I,EAAgBN,aAAa,KAAK/P,UAAY,KAAKsH,SATrD,CAcE,GAAA,KAAKqI,gBAAiB,CACpBY,IAAAA,EAAkB,KAAKxQ,YAAYhf,SAASwvB,gBAC3CjJ,KAAAA,IAAMiJ,EAAkB,KAAKC,UAAUD,EAAiB,KAAKjJ,KAC7DA,KAAAA,IAAIzX,aAAa,WAAY,KAAKmQ,eAEnChc,GAAAA,OAAOY,KAAKyrB,EAAgBN,cAAcruB,SAAS,KAAKse,UACrDsH,KAAAA,IAAM,KAAKkJ,UACdH,EAAgBN,aAAa,KAAK/P,UAClC,KAAKsH,KAEP+I,EAAgBN,aAAa,KAAK/P,UAAY,KAAKsH,QAC9C,CAECmJ,MAAAA,EAAgB1vB,SAAS4oB,cAAc,YAC7C8G,EAAc5gB,aAAa,kBAAmB,KAAKmQ,UAC7C0Q,MAAAA,EAAiBL,EAAgBL,sBACrC,KAAKhQ,UACL2Q,sBAAsB,WAAYF,GAC/BnJ,KAAAA,IAAM,KAAKkJ,UAAUE,EAAgB,KAAKpJ,KAC/C+I,EAAgBN,aAAa,KAAK/P,UAAY,KAAKsH,IAIlDmI,KAAAA,YAAa,EAEb1N,KAAAA,WACmBhT,IAAtBiT,GACEA,EAAkBhC,WAAa,KAAKA,SAClCgC,OACAjT,IAIRyhB,UAAUnvB,EAAMsf,GACP,OAAA,EAAStf,QAAAA,SAAAA,EAAMsf,EAAI,CACxB8L,WAAazpB,GACJA,EAAK4jB,WAAagK,KAAKzE,cAC5BnpB,EAAKqS,aAAa,YAChBrS,EAAKmN,aAAa,YAClBnN,EAAKqR,GAEXuY,kBAAmB,CAACnC,EAAQC,KAEtBD,EAAOgE,YAAY/D,QAKpB,KAAKiF,iBACNlF,EAAOpV,aAAa,aACpBoV,EAAOta,aAAa,cAAgB,KAAK6P,cAIzCyK,EAAOpV,aAAa,oBACpBoV,EAAOta,aAAa,qBAAuB,KAAK6P,YAG9CyK,EAAOpV,aAAa,gBAK1ByX,sBAAwB9pB,IAElBA,GAAAA,EAAK4jB,WAAagK,KAAKzE,aAAc,CACnC0E,IAAAA,EAAU7tB,EAAK8tB,iBAAiB,mBAC/B,IAAA,MAAMC,KAASF,GAEhBE,EAAAA,QAAAA,mBAAAA,EACAA,EAAM5gB,aAAa,iBACnB,GACA,CACE0V,MAAOkL,IAKR,OAAA,GAET9D,aAAc,KAAK0C,kBAGvBM,mBACOF,KAAAA,aAAe,GACfC,KAAAA,sBAAwB,IAE3B,EAAA,OAAA,kBAAA,KAAK1I,IACJvlB,IACKA,EAAGsT,aAAa,+BACb2a,KAAAA,sBACHjuB,EAAGoO,aAAa,8BACdpO,IAGR,CAACA,EAAIie,KAEE+P,KAAAA,aAAa/P,GAAYje,IAIpC+tB,UAAUxI,GAGJ,GAAe,iBAARA,EAAkB,CACvB0J,IAAAA,EAAY1J,EAAIvc,OAChB,GAAC,KAAK4kB,gBAwBH,CACClG,MAAAA,EAAM,KAAK1J,YAAYkR,UAAUC,gBACrCF,EACA,aAEFvH,EAAI8G,gBAAgB1gB,aAAa,WAAY,KAAKmQ,UAClDsH,EAAMmC,EAAI8G,oBA9Be,CACrBvG,IAAAA,EAAW,KAAKjK,YAAYhf,SAAS4oB,cAAc,YAIrDK,GAHFA,EAASnZ,UAAYmgB,EAGnBhH,EAAS3nB,QAAQ4nB,WAAWhZ,OAAS,GACE,IAAvC+Y,EAAS3nB,QAAQ4nB,WAAWhZ,QAC5B+Y,EAAS3nB,QAAQ+oB,WAAWxE,WAAagK,KAAKxE,WACN,IAAvCpC,EAAS3nB,QAAQ4nB,WAAWhZ,SAC1B+Y,EAAS3nB,QAAQ+oB,WAAW/V,aAAa,aACxC2U,EAAS3nB,QAAQ+oB,WAAW/V,aAAa,oBAC7C,CACI8b,IAAAA,EAAM,KAAKpR,YAAYhf,SAAS4oB,cAAc,OAC9CwB,EAAWnB,EAAS3nB,QAAQ+oB,WACzBD,KAAAA,GAAU,CACXE,IAAAA,EAAYF,EAAShc,YACzBgiB,EAAI7F,YAAYH,GAChBA,EAAWE,EAEbrB,EAAS3nB,QAAQipB,YAAY6F,GAG/BnH,EAAS3nB,QAAQ+oB,WAAWvb,aAAa,WAAY,KAAKmQ,UAC1DsH,EAAM0C,EAAS3nB,QAAQ+oB,YAWpB9D,OADPA,EAAIrX,gBAAgB,YACbqX,EAET4I,8CAIO,IAAA,MAAMkB,KAAW,KAAK9J,IAAIwJ,iBAAiB,SAC9CM,EAAQ7e,oBACN,SACA,KAAK8e,kCACL,GAEFD,EAAQnwB,iBACN,SACA,KAAKowB,kCACL,GAINA,iCAAiCvf,GAC/BA,EAAMK,OAAOtC,aAAa,oBAAqB,KAInD,MAAMyhB,aACJrsB,YAAY+a,EAAUuR,EAAWC,EAAcC,GACxCzR,KAAAA,SAAWA,EACXuR,KAAAA,UAAYA,EACZC,KAAAA,aAAeA,EACfC,KAAAA,MAAQA,EACRC,KAAAA,cAAgBD,aAAiBnR,UAAYmR,aAAiBrwB,MAErEuwB,cAAcC,GACR,GAAA,KAAKF,cACF,IAAA,MAAMG,KAAQ,KAAKJ,MACtBG,EAASE,OAAO,KAAKN,aAAcK,QAGrCD,EAASE,OAAO,KAAKN,aAAc,KAAKC,QAQ9C,MAAMM,YACJ9sB,YAAYwkB,EAAM1oB,UACXA,KAAAA,SAAW0oB,EACXlI,KAAAA,WAAa,GACbyQ,KAAAA,4BACAC,KAAAA,gBAAe,GACfC,KAAAA,SAAW,GACXC,KAAAA,eAAiB,GACjBlB,KAAAA,UAAY,IAAImB,UAChBC,KAAAA,YAAc,KAEdC,KAAAA,oBAAsB,EACtBC,KAAAA,sBAAwB,KACxBC,KAAAA,yBAA2B,GAC3BC,KAAAA,mCAAqC,KAE1CjgB,OAAOkgB,WAAa,KAAKC,kBAGpBC,KAAAA,0BAA4B,GAMnCZ,4BACOzQ,KAAAA,WAAa,GACdsR,IAAAA,gBAAkB,KAAK9xB,SAAS+vB,iBAClC,wBAEG,IAAA,MAAMgC,iBAAiBD,gBAAiB,CACrCxL,MAAAA,aAAe,IAAImI,aACvB,KACAsD,cAAc3iB,aAAa,YAC3B4iB,SAASD,cAAc3iB,aAAa,gBACpC2iB,eACA,GAEGvR,KAAAA,WAAW8F,aAAarH,UAAYqH,aACzCA,aAAatF,SAQjBiR,qCAAqCC,GAC/B1R,IAAAA,EAAa,GACb2R,EAAU,CACZC,iBAAkB,GAClBC,eAAgB,IAEb,IAAA,MAAMC,KAASJ,EACdjvB,GAAAA,OAAOY,KAAKyuB,GAAO3xB,SAAS,WAG9BwxB,EAAU,CACRC,sBAC6BpkB,IAA3BskB,EAAMF,iBAAiCE,EAAMF,iBAAmB,GAClEC,oBAC2BrkB,IAAzBskB,EAAMD,eAA+BC,EAAMD,eAAiB,QAE3D,CACOC,EAAM/L,IAClB/F,EAAW8R,EAAMrT,UAAY,IAAIwP,aAC/B,KACA6D,EAAMrT,SACN,CACE4P,IAAKyD,EAAMzD,IACXC,WAAYwD,EAAMxD,WAClBjO,MAAOyR,EAAMzR,MACbC,QAASwR,EAAMxR,SAEjBwR,EAAM/L,KACN,GAIC,MAAA,CAAE/F,WAAYA,EAAY2R,QAASA,GAM5CI,gBAAe,WAAE/R,EAAF,QAAc2R,IAIvBK,IAAAA,EAAoB,GAEnB,IAAA,MAAOvT,EAAUwT,KAAYxvB,OAAOqC,QAAQ,KAAKkb,iBACvBxS,IAAzBwS,EAAWvB,GACbuT,EAAkBvT,GAAYwT,EAE9BD,EAAkBvT,GAAYuB,EAAWvB,GAIxC,IAAA,MAAOA,EAAUwT,KAAYxvB,OAAOqC,QAAQkb,QACXxS,IAAhCwkB,EAAkBvT,KACpBuT,EAAkBvT,GAAYwT,GAQ9BC,IAAAA,EAAgBzvB,OAAOa,OAAO0uB,GAC/BztB,OAAQ0b,GAAMA,EAAEmO,iBAChB5pB,IAAKyb,GAAMA,EAAExB,UAEZ0T,EAAeD,EAAc,GAC7BA,GAAAA,EAAcxiB,OAAS,EACpB,IAAA,MAAM0iB,KAAOF,EACXF,EAAkBI,GAAKlE,aAC1BiE,EAAeC,GAIjBC,IAAAA,EAAsB,CAACF,GACvBG,EAAgB,GACbD,KAAAA,EAAoB3iB,OAAS,GAAG,CAC/B6iB,MAAAA,EAAmBP,EAAkBK,EAAoBtO,SAC3DwO,QAAqB/kB,IAArB+kB,EAAgC,CAC9BC,IAAAA,EAAmB,KAAKxS,WAAWuS,EAAiB9T,UACpDqQ,EAAkBrsB,OAAOa,OAAOgvB,GAAeroB,KAChDgW,GACCxd,OAAOY,KAAK4c,EAAEuO,cAAcruB,SAASoyB,EAAiB9T,WACtDhc,OAAOY,KAAK4c,EAAEwO,uBAAuBtuB,SACnCoyB,EAAiB9T,WAGvB8T,EAAiB1D,MAAMC,EAAiB0D,GACxCF,EAAcC,EAAiB9T,UAAY8T,EACtC,IAAA,MAAME,KAAmBhwB,OAAOY,KACnCkvB,EAAiB/D,cAEjB6D,EAAoBpiB,KAAKwiB,GAEtB,IAAA,MAAMC,KAA4BjwB,OAAOY,KAC5CkvB,EAAiB9D,uBAGdhsB,OAAOY,KAAKkvB,EAAiB/D,cAAcruB,SAC1CuyB,IAGFL,EAAoBpiB,KAAKyiB,IAM5B,IAAA,MAAOjU,EAAUta,KAAc1B,OAAOqC,QAAQ,KAAKkb,YAEnDvd,OAAOY,KAAKivB,GAAenyB,SAASse,IACrC6T,EAAc7T,KAActa,GAE5BA,EAAUie,UAIVuQ,IACAlU,EADAkU,EAAoB,GAEjB,UAAuD,KAA/ClU,EAAWkT,EAAQC,iBAAiBgB,QAE/CnwB,GAAAA,OAAOY,KAAKivB,GAAenyB,SAASse,KACnCkU,EAAkBxyB,SAASse,GAC5B,CACK,IAAA,MAAMoU,KAAiBpwB,OAAOY,KACjCivB,EAAc7T,GAAU+P,cAExBmD,EAAQC,iBAAiB3hB,KAAK4iB,GAEhCF,EAAkB1iB,KAAKqiB,EAAc7T,GAAUjU,iBAKxC8nB,EAJyB7T,EAC7BrY,MAAM,KACN4L,MAAM,GAAI,GACV1J,KAAK,MACsCkmB,aAAa/P,GAG1D,IAAA,MAAMqU,KAAcH,SAChBL,EAAcQ,GAGlB,IAAA,MAAMzE,KAAOsD,EAAQE,eACxB5gB,OAAO8hB,KAAK1E,EAAK,UAGdrO,KAAAA,WAAasS,EAGpBpT,qBAAqBT,EAAUuU,EAAYzT,GAAsB,GACzD0T,MAAAA,EAAwB,KAAKtC,SAASpsB,OACzC2uB,GAAiB,SAAXA,EAAE9uB,MAAmB8uB,EAAE5M,oBAAsB7H,GAElDc,IAAwB,IAAxBA,GAAgC0T,EAAsBvjB,OAAS,EAAG,CAC9DyjB,MAAAA,EAAcF,EAAsB,GACrC,IAAA,MAAOjD,EAAWoD,KAAe3wB,OAAOqC,QAAQkuB,GACnDG,EAAYH,WAAa,KAAKK,aAC5BF,EAAYH,WACZhD,EACAoD,OAGC,CAEH7T,IAAwB,IAAxBA,GACmC,IAAnC9c,OAAOY,KAAK2vB,GAAYtjB,aACMlC,IAA9B,KAAKwS,WAAWvB,GAGhB,OAEEE,IAAAA,GACsB,IAAxBY,QAA8D/R,IAA9B,KAAKwS,WAAWvB,IAC5C,EAAS,OAAA,UAAA,KAAKuB,WAAWvB,GAAU4B,OACnC,GACD,IAAA,MAAO2P,EAAWoD,KAAe3wB,OAAOqC,QAAQkuB,GACnDrU,EAAS,KAAK0U,aAAa1U,EAAQqR,EAAWoD,GAE5C7T,IAAwB,IAAxBA,GAAiC0T,EAAwB,EAAG,CACxDE,MAAAA,EAAcF,EAAsB,GAC1CE,EAAYH,WAAarU,EACzBwU,EAAY5T,oBAAsBA,OAE7BoR,KAAAA,SAAS1gB,KAAK,CACjB7L,KAAM,OACNkiB,kBAAmB7H,EACnBuU,WAAYrU,EACZY,oBAAqBA,KAY7B8T,aAAa1U,EAAQqR,EAAWoD,GAC1BpD,GAAAA,EAAUjqB,WAAW,MAAQiqB,EAAU9d,SAAS,KAC5C,KAAA,yCAED,OAAA,KAAKohB,cAAc3U,EAAQqR,EAAU5pB,MAAM,KAAMgtB,GAE1DE,cAAc3U,EAAQ4U,EAAYH,GAC5BI,IAAAA,EAAQD,EAAW,GAahB5U,OAZmB,IAAtB4U,EAAW7jB,OAEbiP,EAAO6U,GAASJ,OACW5lB,IAAlBmR,EAAO6U,GAChB7U,EAAO6U,GAAS,KAAKF,cAAc,GAAIC,EAAWvhB,MAAM,GAAIohB,GAE5DzU,EAAO6U,GAAS,KAAKF,cACnB3U,EAAO6U,GACPD,EAAWvhB,MAAM,GACjBohB,GAGGzU,EAGTE,eAAeJ,EAAUC,EAAYzc,EAAO,GAAI2c,EAAS,IACjD6U,MAAAA,EAAqB,KAAK9C,SAAS+C,UACtCR,GACY,SAAXA,EAAE9uB,MACF8uB,EAAE5M,oBAAsB7H,GACxByU,EAAExU,aAAeA,GACjBiC,KAAKE,UAAUqS,EAAEjxB,QAAU0e,KAAKE,UAAU5e,IAC1C0e,KAAKE,UAAUqS,EAAEtU,UAAY+B,KAAKE,UAAUjC,IAE5C6U,GAAsB,GACnB9C,KAAAA,SAASvd,OAAOqgB,EAAoB,GAEtC9C,KAAAA,SAAS1gB,KAAK,CACjB7L,KAAM,OACNkiB,kBAAmB7H,EACnBC,WAAYA,EACZzc,KAAMA,EACN2c,OAAQA,IAGZS,eAAeZ,EAAUU,EAAWP,EAAS,GAAIQ,EAAK,MAC/CuR,KAAAA,SAAS1gB,KAAK,CACjB7L,KAAM,OACNkiB,kBAAmB7H,EACnBU,UAAWA,EACXR,OAAQC,EACRQ,GAAIA,IAGRH,kBAAkBR,EAAUuR,EAAWE,GAEjCyD,IAAAA,EAAiB,KAChB,IAAA,MAAMC,KAAMnxB,OAAOa,OAAO,KAAKstB,gBAC9BgD,EAAGnV,WAAaA,GAAYmV,EAAG5D,YAAcA,IAC/C2D,EAAiBC,EAAG3D,cAQrB,GALoB,OAAnB0D,UACK,KAAK/C,eAAe+C,IAIzBzD,aAAiBnR,UAAYmR,aAAiBrwB,QAC9CqwB,EAAMxgB,OAAS,GACjBwgB,aAAiBlR,KACjB,CAEI6U,IAAAA,EAAS,KAEXA,KAAU,MAAVA,GACApxB,OAAOY,KAAK,KAAKutB,gBAAgBzwB,SAAS0zB,IAE1CA,EAASC,KAAKC,SAAS3e,SAAS,IAAI0R,UAAU,GAE3C8J,KAAAA,eAAeiD,GAAU,IAAI9D,aAChCtR,EACAuR,EACA6D,EACA3D,GAGGhR,KAAAA,qBAAqBT,EAAU,CACjCuR,CAAAA,GAAY6D,QAEV,CAEDG,IAAAA,EAAmB,KAAKrD,SAAS+C,UAClCO,GACCA,EAAI3N,oBAAsB7H,GACb,SAAbwV,EAAI7vB,MACJ3B,OAAOY,KAAK4wB,EAAIjB,YAAY7yB,SAAS6vB,IACE,IAAvCvtB,OAAOY,KAAK4wB,EAAIjB,YAAYtjB,QAE5BskB,GAAoB,GACjBrD,KAAAA,SAASvd,OAAO4gB,EAAkB,IAI7CE,4BACMzxB,GAA4C,IAA5CA,OAAOY,KAAK,KAAKutB,gBAAgBlhB,OAE5B,OAAA,KAELykB,IAAAA,EAAK,IAAIC,SACR,IAAA,MAAMR,KAAMnxB,OAAOa,OAAO,KAAKstB,gBAClCgD,EAAGxD,cAAc+D,GAEZA,OAAAA,EAETE,gBAAgBC,GAAgB,GACvB3T,OAAAA,KAAKE,UAAU,CACpBb,WAAYsU,EAAe7xB,OAAOa,OAAO,KAAK0c,YAAYxb,IAAK0uB,GAAMA,EAAEtE,iBAAmB,GAC1F+B,SAAU,KAAKA,WAGnB4D,eAAelG,GACRyC,KAAAA,YAAczC,EAErBmG,gBACQnG,MACAoG,EAAiB,KAAKP,4BACxBO,GAAmB,OAAnBA,EACK,OAAA,IAAIn1B,QAAQ,CAACC,EAASmH,KAC3BnH,EAAQ,QAGNm1B,MAAAA,EACsC,IAA1C,KAAKrD,0BAA0B3hB,OAC3B,GACA,KAAKilB,2BAEJ1jB,OADPyjB,EAAQ,WAAa,SACdzjB,OACJ2jB,MAbS,sBAaE,CACVC,OAAQ,OACRC,MAAO,WACPC,YAAa,cACbC,SAAU,SACVC,SAAU,cACVP,QAASA,EACTxjB,KAAMujB,IAEPjjB,KAAM0jB,IACD,IAACA,EAASC,GAGNhZ,MAFDiZ,KAAAA,6BAA6BF,EAAU,MAAM,GAClDt0B,QAAQy0B,IAAI,oCACNlZ,MAAM,wBAEP+Y,OAAAA,EAASI,SAEjB9jB,KAAM8jB,IAEA,IAAA,MAAMrF,KAAgBxtB,OAAOY,KAAKiyB,EAAKpF,OAAQ,CAG5CqF,MAAAA,EAASD,EAAKpF,MAAMD,GACpBuF,EAAK,KAAK5E,eAAeX,GAC1B/Q,KAAAA,qBAAqBsW,EAAG/W,SAAU,CACpC+W,CAAAA,EAAGxF,WAAYwF,EAAGrF,cAAgBoF,EAASA,EAAO,KAKhDD,OADF1E,KAAAA,eAAiB,GACf0E,EAAKG,uBAGlB9jB,gBAAgBmO,GAAgB,EAAM4Q,GAAiB,EAAM4D,GAAgB,GACrEjG,MAAAA,EACiB,OAArB,KAAKyC,YAAuB,KAAKA,YAAc7f,OAAOykB,SAASC,KAC5DC,KAAAA,8BAA6B,EAAM9V,GACnC0U,KAAAA,gBACFhjB,KAAMikB,IACCI,MAAAA,EAAc,KAAKxB,gBAAgBC,GAEpC3D,KAAAA,SAAW,GACV+D,MAAAA,EACsC,IAA1C,KAAKrD,0BAA0B3hB,OAC3B,GACA,KAAKilB,2BACXD,EAAQ,WAAa,WACQ,OAAzBe,IACFf,EAAQ,0BAA4Be,GAGtCxkB,OACG2jB,MAAMvG,EAAK,CACVwG,OAAQ,OACRC,MAAO,WACPC,YAAa,cACbC,SAAU,SACVC,SAAU,cACVP,QAASA,EACTxjB,KAAM2kB,IAEPrkB,KAAM0jB,IACD,IAACA,EAASC,GAONhZ,MANF2D,IACGiR,KAAAA,qBAAuB,EACvB+E,KAAAA,6BAEPl1B,QAAQm1B,KAAK,yBAA0Bb,GAClCE,KAAAA,6BAA6BF,EAAU,KAAMpV,GAC5C3D,MAAM,wBAEP+Y,OAAAA,EAASI,SAEjB9jB,KAAM8jB,GAAS,KAAK7D,qCAAqC6D,IACzD9jB,KAAMwkB,IACAjE,KAAAA,eAAeiE,GAChBtF,GAAkB5Q,GACf4Q,KAAAA,iBAEH5Q,IACGiR,KAAAA,qBAAuB,EACvB+E,KAAAA,6BAEFG,KAAAA,yBAAwB,EAAMnW,EAAe,KAAKE,cAExDld,MAAON,IACe,wBAAjBA,EAAM0zB,UACRt1B,QAAQm1B,KAAK,wBAAyBvzB,GACjC4yB,KAAAA,6BAA6B,KAAM5yB,EAAOsd,IAE7CA,IACGiR,KAAAA,qBAAuB,EACvB+E,KAAAA,iCAIZhzB,MAAON,IACe,wBAAjBA,EAAM0zB,UACRt1B,QAAQm1B,KAAK,wBAAyBvzB,GACjC4yB,KAAAA,6BAA6B,KAAM5yB,EAAOsd,IAE7CA,IACGiR,KAAAA,qBAAuB,EACvB+E,KAAAA,+BAIbpF,eAAexvB,GAAU,GAEnBi1B,IAAAA,EAAe,KACfzT,GAAS,EACT0T,EAAe,GACd,IAAA,MAAMjyB,KAAa1B,OAAOa,OAAO,KAAK0c,YACrC7b,EAAUgqB,eAAiBzL,IAAkC,IAAzBve,EAAUmqB,aAChD6H,EAAehyB,EACfue,EAAQve,EAAUgqB,gBAMpBiI,EAAanmB,KAAK9L,EAAUyqB,iBAET,OAAjBuH,IACEj1B,EACF+P,OAAOolB,QAAQC,aAAaF,EAAc,GAAID,EAAa9H,KAE3Dpd,OAAOolB,QAAQE,UAAUH,EAAc,GAAID,EAAa9H,MAI9D+C,kBAAkB7gB,GACZA,GAAgB,OAAhBA,EAAM8P,MACRpP,OAAOykB,SAAWl2B,SAASk2B,aACtB,CACA,IAAA,MAAMrjB,KAAQ9B,EAAM8P,MAClB7B,KAAAA,YAAYU,qBAAqB7M,EAAKoM,SAAUpM,EAAKgO,OAAO,GAE/DmW,IAAAA,EAAYjmB,EAAM8P,MAAM7b,IAAK0uB,GAAMA,EAAEzU,UACzC+X,EAAYA,EAAUtxB,KACpB,CAACC,EAAGC,IAAMA,EAAEgB,MAAM,KAAKsJ,OAASvK,EAAEiB,MAAM,KAAKsJ,QAE1C,IAAA,MAAM+mB,KAAMD,EACVhY,KAAAA,YAAYK,eAAe4X,EAAI,WAEjCjY,KAAAA,YAAY7M,iBAAgB,GAAM,GAAO,IAOlDxN,UAAUuyB,GACFpQ,MAAAA,EAAoBoQ,EACvBxR,QAAQ,cACRtW,aAAa,YACT,OAAA,IAAI2P,KAAJ,QAAQ,KAAM+H,GAGvB2P,wBACEU,GAAY,EACZC,GAAiB,EACjB5W,EAAa,IAEb/O,OAAO0T,cACL,IAAI/R,YAAY,kBAAmB,CACjCrB,OAAQ,CACNolB,UAAWA,EACXC,eAAgBA,EAChB5W,WAAYvd,OAAOo0B,YACjBp0B,OAAOqC,QAAQkb,GAAYxb,IAAI,EAAE0D,EAAKkG,KAAS,CAAClG,EAAKkG,EAAI2X,WAMnE6P,6BAA6Be,GAAY,EAAM7W,GAAgB,GACzDA,GAAiB6W,IACd5F,KAAAA,qBAAuB,EACK,IAA7B,KAAKA,sBACFG,KAAAA,mCAAqCjgB,OAAO7O,WAAW,KACrD00B,KAAAA,8BACJ,MAGP7lB,OAAO0T,cACL,IAAI/R,YAAY,uBAAwB,CACtCrB,OAAQ,CACNolB,UAAWA,EACXC,eAAgB9W,MAKxBsV,6BACEF,EAAW,KACX1yB,EAAQ,KACRo0B,GAAiB,GAEjB3lB,OAAO0T,cACL,IAAI/R,YAAY,uBAAwB,CACtCrB,OAAQ,CACNqlB,eAAgBA,EAChBG,aAAwB,OAAVv0B,EACd0yB,SAAUA,EACV1yB,MAAOA,MAKfs0B,6BAEsC,OAAhC,KAAKt3B,SAASyO,gBACX+iB,KAAAA,sBAAwB,KAAKxxB,SAASyO,gBAGxC,EAAA,QAAA,MAAA,KAAKzO,SAASwvB,gBAAkBvtB,IAC/BA,GAAAA,EAAKqS,aAAa,cAAe,OAAO,EAGX,WAA/BrS,EAAKf,QAAQC,eAEkB,WAA/Bc,EAAKf,QAAQC,eAEmB,UAA/Bc,EAAKf,QAAQC,gBACG,aAAdc,EAAK2C,MAAqC,UAAd3C,EAAK2C,OAEpC3C,EAAK6M,aAAa,8BAA+B7M,EAAKu1B,UACjDv1B,EAAKu1B,WACRv1B,EAAKu1B,UAAW,EACX/F,KAAAA,yBAAyBhhB,KAAK,KAC7BxO,EAAKqS,aAAa,iCACpBrS,EAAKu1B,SACkD,SAArDv1B,EAAKmN,aAAa,+BACpBnN,EAAKiN,gBAAgB,oCAMI,UAA/BjN,EAAKf,QAAQC,eAEkB,aAA/Bc,EAAKf,QAAQC,gBAEbc,EAAK6M,aAAa,8BAA+B7M,EAAKw1B,UACtDx1B,EAAK6M,aAAa,8BAA+B7M,EAAKu1B,UACjDv1B,EAAKw1B,WACRx1B,EAAKw1B,UAAW,EAChBx1B,EAAKu1B,UAAW,EACX/F,KAAAA,yBAAyBhhB,KAAK,KAC7BxO,EAAKqS,aAAa,iCACpBrS,EAAKw1B,SACkD,SAArDx1B,EAAKmN,aAAa,+BACpBnN,EAAKiN,gBAAgB,gCAEnBjN,EAAKqS,aAAa,iCACpBrS,EAAKu1B,SACkD,SAArDv1B,EAAKmN,aAAa,+BACpBnN,EAAKiN,gBAAgB,sCAOjConB,4BAEM,GADJ7kB,OAAO9O,aAAa,KAAK+uB,oCACQ,IAA7B,KAAKH,oBAAL,CAIC,IAAA,IAAImG,KAAK,KAAKjG,yBACjBiG,IAEGjG,KAAAA,yBAA2B,GAGC,OAA/B,KAAKD,uBACL,KAAKxxB,SAASsQ,SAAS,KAAKkhB,wBAEvBA,KAAAA,sBAAsBmG,QAExBnG,KAAAA,sBAAwB,MAE/BoG,2BAA2B51B,GACpB6vB,KAAAA,0BAA0BphB,KAAKzO,GAEtCmzB,2BACMlb,IAAAA,EAAS,GACR,IAAA,MAAM4d,KAAqB,KAAKhG,0BACnC5X,EAAS,IAAKA,KAAW4d,KAEpB5d,OAAAA,EAETiN,UAAU3iB,GACD,OAAA,EAAUA,OAAAA,WAAAA,GAEnBuzB,cAAcnzB,EAAW3C,GACnB2C,aAAqB0I,SACvB1I,EAAY,KAAK3E,SAAS+3B,2BAA2BpzB,QAEtCA,EAAAA,OAAAA,kBAAAA,EAAW3C,GAE9Bg2B,aAAah2B,IACN,EAAA,QAAA,MAAA,KAAKhC,SAASwvB,gBAAiBxtB,IA5qBtB,QAAA,YAAA;;AC5QlB,aAFA,IAAA,EAAA,QAAA,eACAyP,OAAOuN,YAAc,IAAIgS,EAAJ,YAAgBhxB,UACrCyR,OAAOuN,YAAYyX,yBAAwB,GAAO","file":"jembe.js","sourceRoot":"../../src/js","sourcesContent":["\n// Thanks @stimulus:\n// https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts\nexport function domReady() {\n    return new Promise(resolve => {\n        if (document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", resolve)\n        } else {\n            resolve()\n        }\n    })\n}\n\nexport function arrayUnique(array) {\n    return Array.from(new Set(array))\n}\n\nexport function isTesting() {\n    return navigator.userAgent, navigator.userAgent.includes(\"Node.js\")\n        || navigator.userAgent.includes(\"jsdom\")\n}\n\nexport function checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB\n}\n\nexport function warnIfMalformedTemplate(el, directive) {\n    if (el.tagName.toLowerCase() !== 'template') {\n        console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`)\n    } else if (el.content.childElementCount !== 1) {\n        console.warn(`Alpine: <template> tag with [${directive}] encountered with an unexpected number of root elements. Make sure <template> has a single root element. `)\n    }\n}\n\nexport function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase()\n}\n\nexport function camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase())\n}\n\nexport function walk(el, callback) {\n    if (callback(el) === false) return\n\n    let node = el.firstElementChild\n\n    while (node) {\n        walk(node, callback)\n\n        node = node.nextElementSibling\n    }\n}\n\nexport function debounce(func, wait) {\n    var timeout\n    return function () {\n        var context = this, args = arguments\n        var later = function () {\n            timeout = null\n            func.apply(context, args)\n        }\n        clearTimeout(timeout)\n        timeout = setTimeout(later, wait)\n    }\n}\n\nconst handleError = (el, expression, error) => {\n    console.warn(`Jembe Error: \"${error}\"\\n\\nExpression: \"${expression}\"\\nElement:`, el);\n\n    if (! isTesting()) {\n        Object.assign(error, { el, expression })\n        throw error;\n    }\n}\n\nfunction tryCatch(cb, { el, expression }) {\n    try {\n        const value = cb();\n        return value instanceof Promise\n            ? value.catch((e) => handleError(el, expression, e))\n            : value;\n    } catch (e) {\n        handleError(el, expression, e)\n    }\n}\n\nexport function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n        if (typeof expression === 'function') {\n            return expression.call(dataContext)\n        }\n\n        return (new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`))(\n            dataContext, ...Object.values(additionalHelperVariables)\n        )\n    }, { el, expression })\n}\n\nexport function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n        if (typeof expression === 'function') {\n            return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']))\n        }\n\n        let AsyncFunction = Function\n\n        /* MODERN-ONLY:START */\n            AsyncFunction = Object.getPrototypeOf(async function(){}).constructor\n        /* MODERN-ONLY:END */\n\n        // For the cases when users pass only a function reference to the caller: `jmb-on:click=\"foo\"`\n        // Where \"foo\" is a function. Also, we'll pass the function the event instance when we call it.\n        if (Object.keys(dataContext).includes(expression)) {\n            let methodReference = (new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`))(\n                dataContext, ...Object.values(additionalHelperVariables)\n            )\n\n            if (typeof methodReference === 'function') {\n                return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']))\n            } else {\n                return Promise.resolve()\n            }\n        }\n\n        return Promise.resolve((new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`))(\n            dataContext, ...Object.values(additionalHelperVariables)\n        ))\n    }, { el, expression })\n}\n\nconst xAttrRE = /^jmb-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread|scope)\\b/\n\nexport function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name)\n\n    return xAttrRE.test(name)\n}\n\nexport function getXAttrs(el, component, type) {\n    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute)\n\n    // Get an object of directives from jmb-spread.\n    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0]\n\n    if (spreadDirective) {\n        let spreadObject = saferEval(el, spreadDirective.expression, component.$data)\n\n        // Add jmb-spread directives to the pile of existing directives.\n        directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({ name, value })))\n    }\n\n    if (type) return directives.filter(i => i.type === type)\n\n    return sortDirectives(directives)\n}\n\nfunction sortDirectives(directives) {\n    let directiveOrder = ['bind', 'model', 'show', 'catch-all']\n\n    return directives.sort((a, b) => {\n        let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type\n        let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type\n\n        return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB)\n    })\n}\n\nexport function parseHtmlAttribute({ name, value }) {\n    const normalizedName = replaceAtAndColonWithStandardSyntax(name)\n\n    const typeMatch = normalizedName.match(xAttrRE)\n    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\\-:]+)/)\n    const modifiers = normalizedName.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || []\n\n    return {\n        type: typeMatch ? typeMatch[1] : null,\n        value: valueMatch ? valueMatch[1] : null,\n        modifiers: modifiers.map(i => i.replace('.', '')),\n        expression: value,\n    }\n}\n\nexport function isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = [\n        'disabled','checked','required','readonly','hidden','open', 'selected',\n        'autofocus', 'itemscope', 'multiple', 'novalidate','allowfullscreen',\n        'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop',\n        'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer',\n        'nomodule'\n    ]\n\n    return booleanAttributes.includes(attrName)\n}\n\nexport function replaceAtAndColonWithStandardSyntax(name) {\n    if (name.startsWith('@')) {\n        return name.replace('@', 'jmb-on:')\n    } else if (name.startsWith(':')) {\n        return name.replace(':', 'jmb-bind:')\n    }\n\n    return name\n}\n\nexport function convertClassStringToArray(classList, filterFn = Boolean) {\n    return classList.split(' ').filter(filterFn)\n}\n\nexport const TRANSITION_TYPE_IN = 'in'\nexport const TRANSITION_TYPE_OUT = 'out'\nexport const TRANSITION_CANCELLED = 'cancelled'\n\nexport function transitionIn(el, show, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return show()\n\n    if (el.__jmb_transition && el.__jmb_transition.type === TRANSITION_TYPE_IN) {\n        // there is already a similar transition going on, this was probably triggered by\n        // a change in a different property, let's just leave the previous one doing its job\n        return\n    }\n\n    const attrs = getXAttrs(el, component, 'transition')\n    const showAttr = getXAttrs(el, component, 'show')[0]\n\n    // If this is triggered by a jmb-show.transition.\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n        let modifiers = showAttr.modifiers\n\n        // If jmb-show.transition.out, we'll skip the \"in\" transition.\n        if (modifiers.includes('out') && ! modifiers.includes('in')) return show()\n\n        const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out')\n\n        // If jmb-show.transition.in...out... only use \"in\" related modifiers for this transition.\n        modifiers = settingBothSidesOfTransition\n            ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers\n\n        transitionHelperIn(el, modifiers, show, reject)\n    // Otherwise, we can assume jmb-transition:enter.\n    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {\n        transitionClassesIn(el, component, attrs, show, reject)\n    } else {\n    // If neither, just show that damn thing.\n        show()\n    }\n}\n\nexport function transitionOut(el, hide, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return hide()\n\n    if (el.__jmb_transition && el.__jmb_transition.type === TRANSITION_TYPE_OUT) {\n        // there is already a similar transition going on, this was probably triggered by\n        // a change in a different property, let's just leave the previous one doing its job\n        return\n    }\n\n    const attrs = getXAttrs(el, component, 'transition')\n    const showAttr = getXAttrs(el, component, 'show')[0]\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n        let modifiers = showAttr.modifiers\n\n        if (modifiers.includes('in') && ! modifiers.includes('out')) return hide()\n\n        const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out')\n\n        modifiers = settingBothSidesOfTransition\n            ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers\n\n        transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject)\n    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {\n        transitionClassesOut(el, component, attrs, hide, reject)\n    } else {\n        hide()\n    }\n}\n\nexport function transitionHelperIn(el, modifiers, showCallback, reject) {\n    // Default values inspired by: https://material.io/design/motion/speed.html#duration\n    const styleValues = {\n        duration: modifierValue(modifiers, 'duration', 150),\n        origin: modifierValue(modifiers, 'origin', 'center'),\n        first: {\n            opacity: 0,\n            scale: modifierValue(modifiers, 'scale', 95),\n        },\n        second: {\n            opacity: 1,\n            scale: 100,\n        },\n    }\n\n    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN)\n}\n\nexport function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {\n    // Make the \"out\" transition .5x slower than the \"in\". (Visually better)\n    // HOWEVER, if they explicitly set a duration for the \"out\" transition,\n    // use that.\n    const duration = settingBothSidesOfTransition\n        ? modifierValue(modifiers, 'duration', 150)\n        : modifierValue(modifiers, 'duration', 150) / 2\n\n    const styleValues = {\n        duration: duration,\n        origin: modifierValue(modifiers, 'origin', 'center'),\n        first: {\n            opacity: 1,\n            scale: 100,\n        },\n        second: {\n            opacity: 0,\n            scale: modifierValue(modifiers, 'scale', 95),\n        },\n    }\n\n    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT)\n}\n\nfunction modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback\n\n    // If it IS present, grab the value after it: jmb-show.transition.duration.500ms\n    const rawValue = modifiers[modifiers.indexOf(key) + 1]\n\n    if (! rawValue) return fallback\n\n    if (key === 'scale') {\n        // Check if the very next value is NOT a number and return the fallback.\n        // If jmb-show.transition.scale, we'll use the default scale value.\n        // That is how a user opts out of the opacity transition.\n        if (! isNumeric(rawValue)) return fallback\n    }\n\n    if (key === 'duration') {\n        // Support jmb-show.transition.duration.500ms && duration.500\n        let match = rawValue.match(/([0-9]+)ms/)\n        if (match) return match[1]\n    }\n\n    if (key === 'origin') {\n        // Support chaining origin directions: jmb-show.transition.top.right\n        if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n            return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ')\n        }\n    }\n\n    return rawValue\n}\n\nexport function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {\n    // clear the previous transition if exists to avoid caching the wrong styles\n    if (el.__jmb_transition) {\n        el.__jmb_transition.cancel && el.__jmb_transition.cancel()\n    }\n\n    // If the user set these style values, we'll put them back when we're done with them.\n    const opacityCache = el.style.opacity\n    const transformCache = el.style.transform\n    const transformOriginCache = el.style.transformOrigin\n\n    // If no modifiers are present: jmb-show.transition, we'll default to both opacity and scale.\n    const noModifiers = ! modifiers.includes('opacity') && ! modifiers.includes('scale')\n    const transitionOpacity = noModifiers || modifiers.includes('opacity')\n    const transitionScale = noModifiers || modifiers.includes('scale')\n\n    // These are the explicit stages of a transition (same stages for in and for out).\n    // This way you can get a birds eye view of the hooks, and the differences\n    // between them.\n    const stages = {\n        start() {\n            if (transitionOpacity) el.style.opacity = styleValues.first.opacity\n            if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`\n        },\n        during() {\n            if (transitionScale) el.style.transformOrigin = styleValues.origin\n            el.style.transitionProperty = [(transitionOpacity ? `opacity` : ``), (transitionScale ? `transform` : ``)].join(' ').trim()\n            el.style.transitionDuration = `${styleValues.duration / 1000}s`\n            el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`\n        },\n        show() {\n            hook1()\n        },\n        end() {\n            if (transitionOpacity) el.style.opacity = styleValues.second.opacity\n            if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`\n        },\n        hide() {\n            hook2()\n        },\n        cleanup() {\n            if (transitionOpacity) el.style.opacity = opacityCache\n            if (transitionScale) el.style.transform = transformCache\n            if (transitionScale) el.style.transformOrigin = transformOriginCache\n            el.style.transitionProperty = null\n            el.style.transitionDuration = null\n            el.style.transitionTimingFunction = null\n        },\n    }\n\n    transition(el, stages, type, reject)\n}\n\nconst ensureStringExpression = (expression, el, component) => {\n    return typeof expression === 'function'\n        ? component.evaluateReturnExpression(el, expression)\n        : expression\n}\n\nexport function transitionClassesIn(el, component, directives, showCallback, reject) {\n    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || { expression: '' }).expression, el, component))\n    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || { expression: '' }).expression, el, component))\n    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || { expression: '' }).expression, el, component))\n\n    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject)\n}\n\nexport function transitionClassesOut(el, component, directives, hideCallback, reject) {\n    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || { expression: '' }).expression, el, component))\n    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || { expression: '' }).expression, el, component))\n    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || { expression: '' }).expression, el, component))\n\n    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject)\n}\n\nexport function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {\n    // clear the previous transition if exists to avoid caching the wrong classes\n    if (el.__jmb_transition) {\n        el.__jmb_transition.cancel && el.__jmb_transition.cancel()\n    }\n\n    const originalClasses = el.__jmb_original_classes || []\n\n    const stages = {\n        start() {\n            el.classList.add(...classesStart)\n        },\n        during() {\n            el.classList.add(...classesDuring)\n        },\n        show() {\n            hook1()\n        },\n        end() {\n            // Don't remove classes that were in the original class attribute.\n            el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)))\n            el.classList.add(...classesEnd)\n        },\n        hide() {\n            hook2()\n        },\n        cleanup() {\n            el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)))\n            el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)))\n        },\n    }\n\n    transition(el, stages, type, reject)\n}\n\nexport function transition(el, stages, type, reject) {\n    const finish = once(() => {\n        stages.hide()\n\n        // Adding an \"isConnected\" check, in case the callback\n        // removed the element from the DOM.\n        if (el.isConnected) {\n            stages.cleanup()\n        }\n\n        delete el.__jmb_transition\n    })\n\n    el.__jmb_transition = {\n        // Set transition type so we can avoid clearing transition if the direction is the same\n       type: type,\n        // create a callback for the last stages of the transition so we can call it\n        // from different point and early terminate it. Once will ensure that function\n        // is only called one time.\n        cancel: once(() => {\n            reject(TRANSITION_CANCELLED)\n\n            finish()\n        }),\n        finish,\n        // This store the next animation frame so we can cancel it\n        nextFrame: null\n    }\n\n    stages.start()\n    stages.during()\n\n    el.__jmb_transition.nextFrame = requestAnimationFrame(() => {\n        // Note: Safari's transitionDuration property will list out comma separated transition durations\n        // for every single transition property. Let's grab the first one and call it a day.\n        let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n\n        if (duration === 0) {\n            duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000\n        }\n\n        stages.show()\n\n        el.__jmb_transition.nextFrame = requestAnimationFrame(() => {\n            stages.end()\n\n            setTimeout(el.__jmb_transition.finish, duration)\n        })\n    });\n}\n\nexport function isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n\n// Thanks @vuejs\n// https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js\nexport function once(callback) {\n    let called = false\n\n    return function () {\n        if (! called) {\n            called = true\n            callback.apply(this, arguments)\n        }\n    }\n}\n","import { transitionIn, transitionOut, getXAttrs, warnIfMalformedTemplate, isNumeric } from '../utils'\n\nexport function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(templateEl, 'jmb-for')\n\n    let iteratorNames = typeof expression === 'function'\n        ? parseForExpression(component.evaluateReturnExpression(templateEl, expression))\n        : parseForExpression(expression)\n\n    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars)\n\n    // As we walk the array, we'll also walk the DOM (updating/creating as we go).\n    let currentEl = templateEl\n    items.forEach((item, index) => {\n        let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars())\n        let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables)\n        let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey)\n\n        // If we haven't found a matching key, insert the element at the current position.\n        if (! nextEl) {\n            nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl)\n\n            // And transition it in if it's not the first page load.\n            transitionIn(nextEl, () => {}, () => {}, component, initialUpdate)\n\n            nextEl.__jmb_for = iterationScopeVariables\n            component.initializeElements(nextEl, () => nextEl.__jmb_for)\n        // Otherwise update the element we found.\n        } else {\n            // Temporarily remove the key indicator to allow the normal \"updateElements\" to work.\n            delete nextEl.__jmb_for_key\n\n            nextEl.__jmb_for = iterationScopeVariables\n            component.updateElements(nextEl, () => nextEl.__jmb_for)\n        }\n\n        currentEl = nextEl\n        currentEl.__jmb_for_key = currentKey\n    })\n\n    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component)\n}\n\n// This was taken from VueJS 2.* core. Thanks Vue!\nfunction parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n    let stripParensRE = /^\\(|\\)$/g\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n    let inMatch = String(expression).match(forAliasRE)\n    if (! inMatch) return\n    let res = {}\n    res.items = inMatch[2].trim()\n    let item = inMatch[1].trim().replace(stripParensRE, '')\n    let iteratorMatch = item.match(forIteratorRE)\n\n    if (iteratorMatch) {\n        res.item = item.replace(forIteratorRE, '').trim()\n        res.index = iteratorMatch[1].trim()\n\n        if (iteratorMatch[2]) {\n            res.collection = iteratorMatch[2].trim()\n        }\n    } else {\n        res.item = item\n    }\n    return res\n}\n\nfunction getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = extraVars ? {...extraVars} : {}\n    scopeVariables[iteratorNames.item] = item\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items\n\n    return scopeVariables\n}\n\nfunction generateKeyForIteration(component, el, index, iterationScopeVariables) {\n    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]\n\n    // If the dev hasn't specified a key, just return the index of the iteration.\n    if (! bindKeyAttribute) return index\n\n    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables)\n}\n\nfunction evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {\n    let ifAttribute = getXAttrs(el, component, 'if')[0]\n\n    if (ifAttribute && ! component.evaluateReturnExpression(el, ifAttribute.expression)) {\n        return []\n    }\n\n    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars)\n\n    // This adds support for the `i in n` syntax.\n    if (isNumeric(items) && items >= 0) {\n        items = Array.from(Array(items).keys(), i => i + 1)\n    }\n\n    return items\n}\n\nfunction addElementInLoopAfterCurrentEl(templateEl, currentEl) {\n    let clone = document.importNode(templateEl.content, true  )\n\n    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling)\n\n    return currentEl.nextElementSibling\n}\n\nfunction lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {\n    if (! nextEl) return\n\n    // If we are already past the jmb-for generated elements, we don't need to look ahead.\n    if (nextEl.__jmb_for_key === undefined) return\n\n    // If the the key's DO match, no need to look ahead.\n    if (nextEl.__jmb_for_key === currentKey) return nextEl\n\n    // If they don't, we'll look ahead for a match.\n    // If we find it, we'll move it to the current position in the loop.\n    let tmpNextEl = nextEl\n\n    while(tmpNextEl) {\n        if (tmpNextEl.__jmb_for_key === currentKey) {\n            return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl)\n        }\n\n        tmpNextEl = (tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__jmb_for_key !== undefined) ? tmpNextEl.nextElementSibling : false\n    }\n}\n\nfunction removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {\n    var nextElementFromOldLoop = (currentEl.nextElementSibling && currentEl.nextElementSibling.__jmb_for_key !== undefined) ? currentEl.nextElementSibling : false\n\n    while (nextElementFromOldLoop) {\n        let nextElementFromOldLoopImmutable = nextElementFromOldLoop\n        let nextSibling = nextElementFromOldLoop.nextElementSibling\n        transitionOut(nextElementFromOldLoop, () => {\n            nextElementFromOldLoopImmutable.remove()\n        }, () => {}, component)\n        nextElementFromOldLoop = (nextSibling && nextSibling.__jmb_for_key !== undefined) ? nextSibling : false\n    }\n}\n","import { arrayUnique, checkedAttrLooseCompare, isBooleanAttr, convertClassStringToArray, camelCase } from '../utils'\nimport Alpine from '../index'\n\nexport function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars)\n\n    if (attrName === 'value') {\n        if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return\n\n        // If nested model key is undefined, set the default value to empty string.\n        if (value === undefined && String(expression).match(/\\./)) {\n            value = ''\n        }\n\n        if (el.type === 'radio') {\n            // Set radio value from jmb-bind:value, if no \"value\" attribute exists.\n            // If there are any initial state values, radio will have a correct\n            // \"checked\" value since jmb-bind:value is processed before jmb-model.\n            if (el.attributes.value === undefined && attrType === 'bind') {\n                el.value = value\n            } else if (attrType !== 'bind') {\n                el.checked = checkedAttrLooseCompare(el.value, value)\n            }\n        } else if (el.type === 'checkbox') {\n            // If we are explicitly binding a string to the :value, set the string,\n            // If the value is a boolean, leave it alone, it will be set to \"on\"\n            // automatically.\n            if (typeof value !== 'boolean' && ! [null, undefined].includes(value) && attrType === 'bind') {\n                el.value = String(value)\n            } else if (attrType !== 'bind') {\n                if (Array.isArray(value)) {\n                    // I'm purposely not using Array.includes here because it's\n                    // strict, and because of Numeric/String mis-casting, I\n                    // want the \"includes\" to be \"fuzzy\".\n                    el.checked = value.some(val => checkedAttrLooseCompare(val, el.value))\n                } else {\n                    el.checked = !!value\n                }\n            }\n        } else if (el.tagName === 'SELECT') {\n            updateSelect(el, value)\n        } else {\n            if (el.value === value) return\n\n            el.value = value\n        }\n    } else if (attrName === 'class') {\n        if (Array.isArray(value)) {\n            const originalClasses = el.__jmb_original_classes || []\n            el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '))\n        } else if (typeof value === 'object') {\n            // Sorting the keys / class names by their boolean value will ensure that\n            // anything that evaluates to `false` and needs to remove classes is run first.\n            const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);\n\n            keysSortedByBooleanValue.forEach(classNames => {\n                if (value[classNames]) {\n                    convertClassStringToArray(classNames).forEach(className => el.classList.add(className))\n                } else {\n                    convertClassStringToArray(classNames).forEach(className => el.classList.remove(className))\n                }\n            })\n        } else {\n            const originalClasses = el.__jmb_original_classes || []\n            const newClasses = value ? convertClassStringToArray(value) : []\n            el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '))\n        }\n    } else {\n        attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName\n\n        // If an attribute's bound value is null, undefined or false, remove the attribute\n        if ([null, undefined, false].includes(value)) {\n            el.removeAttribute(attrName)\n        } else {\n            isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value)\n        }\n    }\n}\n\nfunction setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n        el.setAttribute(attrName, value)\n    }\n}\n\nfunction updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => { return value + '' })\n\n    Array.from(el.options).forEach(option => {\n        option.selected = arrayWrappedValue.includes(option.value || option.text)\n    })\n}\n","export function handleTextDirective(el, output, expression) {\n    // If nested model key is undefined, set the default value to empty string.\n    if (output === undefined && String(expression).match(/\\./)) {\n        output = ''\n    }\n\n    el.textContent = output\n}\n","export function handleHtmlDirective(component, el, expression, extraVars) {\n    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars)\n}\n","import { transitionIn, transitionOut } from '../utils'\n\nexport function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {\n    const hide = () => {\n        el.style.display = 'none'\n        el.__jmb_is_shown = false\n    }\n\n    const show = () => {\n        if (el.style.length === 1 && el.style.display === 'none') {\n            el.removeAttribute('style')\n        } else {\n            el.style.removeProperty('display')\n        }\n\n        el.__jmb_is_shown = true\n    }\n\n    if (initialUpdate === true) {\n        if (value) {\n            show()\n        } else {\n            hide()\n        }\n        return\n    }\n\n    const handle = (resolve, reject) => {\n        if (value) {\n            if (el.style.display === 'none' || el.__jmb_transition) {\n                transitionIn(el, () => {\n                    show()\n                }, reject, component)\n            }\n            resolve(() => {})\n        } else {\n            if (el.style.display !== 'none') {\n                transitionOut(el, () => {\n                    resolve(() => {\n                        hide()\n                    })\n                }, reject, component)\n            } else {\n                resolve(() => {})\n            }\n        }\n    }\n\n    // The working of jmb-show is a bit complex because we need to\n    // wait for any child transitions to finish before hiding\n    // some element. Also, this has to be done recursively.\n\n    // If jmb-show.immediate, foregoe the waiting.\n    if (modifiers.includes('immediate')) {\n        handle(finish => finish(), () => {})\n        return\n    }\n\n    // jmb-show is encountered during a DOM tree walk. If an element\n    // we encounter is NOT a child of another jmb-show element we\n    // can execute the previous jmb-show stack (if one exists).\n    if (component.showDirectiveLastElement && ! component.showDirectiveLastElement.contains(el)) {\n        component.executeAndClearRemainingShowDirectiveStack()\n    }\n\n    component.showDirectiveStack.push(handle)\n\n    component.showDirectiveLastElement = el\n}\n","import { transitionIn, transitionOut, warnIfMalformedTemplate } from '../utils'\n\nexport function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(el, 'jmb-if')\n\n    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__jmb_inserted_me === true\n\n    if (expressionResult && (! elementHasAlreadyBeenAdded || el.__jmb_transition)) {\n        const clone = document.importNode(el.content, true);\n\n        el.parentElement.insertBefore(clone, el.nextElementSibling)\n\n        transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate)\n\n        component.initializeElements(el.nextElementSibling, extraVars)\n\n        el.nextElementSibling.__jmb_inserted_me = true\n    } else if (! expressionResult && elementHasAlreadyBeenAdded) {\n        transitionOut(el.nextElementSibling, () => {\n            el.nextElementSibling.remove()\n        }, () => {}, component, initialUpdate)\n    }\n}\n","import { kebabCase, camelCase, debounce, isNumeric } from '../utils'\n\nexport function registerListener(component, el, event, modifiers, expression, extraVars = () => { }, mutated=false) {\n    const options = {\n        passive: modifiers.includes('passive'),\n    };\n\n    if (modifiers.includes('camel')) {\n        event = camelCase(event);\n    }\n\n    let handler, listenerTarget\n\n    if (modifiers.includes('away')) {\n        listenerTarget = document\n\n        handler = e => {\n            // Don't do anything if the click came from the element or within it.\n            if (el.contains(e.target)) return\n\n            // Don't do anything if this element isn't currently visible.\n            if (el.offsetWidth < 1 && el.offsetHeight < 1) return\n\n            // Now that we are sure the element is visible, AND the click\n            // is from outside it, let's run the expression.\n            runListenerHandler(component, expression, e, extraVars, el)\n\n            if (modifiers.includes('once')) {\n                document.removeEventListener(event, handler, options)\n            }\n        }\n    } else {\n        listenerTarget = modifiers.includes('window')\n            ? window : (modifiers.includes('document') ? document : el)\n\n        handler = e => {\n            // Remove this global event handler if the element that declared it\n            // has been removed. It's now stale.\n            if (listenerTarget === window || listenerTarget === document) {\n                if (!document.body.contains(el)) {\n                    listenerTarget.removeEventListener(event, handler, options)\n                    return\n                }\n            }\n\n            if (isKeyEvent(event)) {\n                if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n                    return\n                }\n            }\n\n            if (modifiers.includes('prevent')) e.preventDefault()\n            if (modifiers.includes('stop')) e.stopPropagation()\n\n            // If the .self modifier isn't present, or if it is present and\n            // the target element matches the element we are registering the\n            // event on, run the handler\n            const target = e.type === 'ready'? e.detail['target'] : e.target\n            if (!modifiers.includes('self') || target === el) {\n                const returnValue = runListenerHandler(component, expression, e, extraVars, el)\n\n                returnValue.then(value => {\n                    if (value === false) {\n                        e.preventDefault()\n                    } else {\n                        if (modifiers.includes('once')) {\n                            listenerTarget.removeEventListener(event, handler, options)\n                        }\n                    }\n                })\n            }\n        }\n    }\n\n    // if expression adds commands to jembeClient\n    // then execute jembeClient comands and refresh page\n    if (!modifiers.includes('defer')) {\n        handler = ((component, func) => {\n            return e => {\n                component.$jmb.callsCommands = false\n                func(e)\n                if (component.$jmb.callsCommands === true) {\n                    component.$jmb.executeCommands(!modifiers.includes('nonblocking'))\n                }\n            }\n        })(component, handler)\n    }\n\n    if (modifiers.includes('debounce')) {\n        let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait'\n        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250\n        handler = debounce(handler, wait, this)\n    }\n    const delayModifier = modifiers.find(m => m.startsWith('delay'))\n    if (delayModifier !== undefined) {\n        const delayId = delayModifier.split('-').slice(1).join('-')\n        let delayTime = modifiers[modifiers.indexOf(delayModifier) + 1]\n        delayTime = delayTime !== undefined && delayTime.endsWith('ms') ? parseInt(delayTime.substr(0, delayTime.length - 2)) : 250\n        if (delayId === undefined) {\n            handler = ((comp, func) => {\n                return (e) => {\n                    var timerId = window.setTimeout(function () { func(e) }, delayTime);\n                    comp.unnamedTimers.push(timerId)\n\n                }\n            })(component, handler)\n        } else {\n            let start = new Date().getTime()\n            if (component.originalComponentNamedTimers[delayId] !== undefined) {\n                start = component.originalComponentNamedTimers[delayId].start\n                delayTime = delayTime - ((new Date().getTime()) - start)\n            }\n\n            if (delayTime > 0) {\n                handler = ((comp, func) => {\n                    return (e) => {\n                        var timerId = window.setTimeout(function () {\n                            delete comp.namedTimers[delayId]\n                            window.clearTimeout(timerId)\n                            func(e);\n                        }, delayTime);\n                        comp.namedTimers[delayId] = {\n                            id: timerId,\n                            start: start\n                        }\n                    }\n                })(component, handler)\n            } else {\n                //run emidiatly like on:ready\n                component.nextTickStack.push(() => {\n                    handler(new CustomEvent('ready', {detail: {target: el }}))\n                })\n                return // dont register listener nor \n            }\n        }\n    }\n\n    if (event === 'ready') {\n        if (! (mutated && modifiers.includes(\"once\"))) {\n            component.nextTickStack.push(() => {\n                handler(new CustomEvent('ready', {detail:{ target: el }}))\n            })\n        }\n    } else {\n        // register listener so it can be removed when morphing dom\n        if (el.__jmb_listeners === undefined) {\n            el.__jmb_listeners = []\n        }\n        el.__jmb_listeners.push([listenerTarget, event, handler, options])\n        listenerTarget.addEventListener(event, handler, options)\n    }\n}\n\nfunction runListenerHandler(component, expression, e, extraVars, self) {\n    const target = e.type === 'ready'? e.detail['target'] : e.target\n    return component.evaluateCommandExpression(target, expression, () => {\n        return { ...extraVars(), '$event': e, '$self': self }\n    })\n}\n\nfunction isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event)\n}\n\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n        return !['window', 'document', 'prevent', 'stop'].includes(i)\n    })\n\n    if (keyModifiers.includes('debounce')) {\n        let debounceIndex = keyModifiers.indexOf('debounce')\n        keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1)\n    }\n\n    // If no modifier is specified, we'll call it a press.\n    if (keyModifiers.length === 0) return false\n\n    // If one is passed, AND it matches the key pressed, we'll call it a press.\n    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false\n\n    // The user is listening for key combinations.\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super']\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier))\n\n    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i))\n\n    if (selectedSystemKeyModifiers.length > 0) {\n        const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n            // Alias \"cmd\" and \"super\" to \"meta\"\n            if (modifier === 'cmd' || modifier === 'super') modifier = 'meta'\n\n            return e[`${modifier}Key`]\n        })\n\n        // If all the modifiers selected are pressed, ...\n        if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n            // AND the remaining key is pressed as well. It's a press.\n            if (keyModifiers[0] === keyToModifier(e.key)) return false\n        }\n    }\n\n    // We'll call it NOT a valid keypress.\n    return true\n}\n\nfunction keyToModifier(key) {\n    switch (key) {\n        case '/':\n            return 'slash'\n        case ' ':\n        case 'Spacebar':\n            return 'space'\n        default:\n            return key && kebabCase(key)\n    }\n}\n","import { registerListener } from './on'\nimport { isNumeric, checkedAttrLooseCompare } from '../utils'\n\nexport function registerModelListener(component, el, modifiers, expression, extraVars) {\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = (el.tagName.toLowerCase() === 'select')\n        || ['checkbox', 'radio'].includes(el.type)\n        || modifiers.includes('lazy')\n        ? 'change' : 'input'\n\n    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`\n\n    registerListener(component, el, event, modifiers, listenerExpression, () => {\n        return {\n            ...extraVars(),\n            rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression),\n        }\n    })\n}\n\nfunction generateModelAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n        // Radio buttons only work properly when they share a name attribute.\n        // People might assume we take care of that for them, because\n        // they already set a shared \"jmb-model\" attribute.\n        if (! el.hasAttribute('name')) el.setAttribute('name', expression)\n    }\n\n    return (event, currentValue) => {\n        // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n        if (event instanceof CustomEvent && event.detail) {\n            return event.detail\n        } else if (el.type === 'checkbox') {\n            // If the data we are binding to is an array, toggle its value inside the array.\n            if (Array.isArray(currentValue)) {\n                const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value\n                return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue))\n            } else {\n                return event.target.checked\n            }\n        } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n            return modifiers.includes('number')\n                ? Array.from(event.target.selectedOptions).map(option => {\n                    const rawValue = option.value || option.text\n                    return safeParseNumber(rawValue)\n                })\n                : Array.from(event.target.selectedOptions).map(option => {\n                    return option.value || option.text\n                })\n        } else {\n            const rawValue = event.target.value\n            return modifiers.includes('number')\n                ? safeParseNumber(rawValue)\n                : (modifiers.includes('trim') ? rawValue.trim() : rawValue)\n        }\n    }\n}\n\nfunction safeParseNumber(rawValue) {\n    const number = rawValue ? parseFloat(rawValue) : null\n    return isNumeric(number) ? number : rawValue\n}\n","/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst { isArray } = Array;\nconst { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\nconst { push: ArrayPush, concat: ArrayConcat, } = Array.prototype;\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nconst proxyToValueMap = new WeakMap();\nfunction registerProxy(proxy, value) {\n    proxyToValueMap.set(proxy, value);\n}\nconst unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nclass BaseProxyHandler {\n    constructor(membrane, value) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n    }\n    // Shared utility methods\n    wrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            descriptor.value = this.wrapValue(descriptor.value);\n        }\n        else {\n            const { set: originalSet, get: originalGet } = descriptor;\n            if (!isUndefined(originalGet)) {\n                descriptor.get = this.wrapGetter(originalGet);\n            }\n            if (!isUndefined(originalSet)) {\n                descriptor.set = this.wrapSetter(originalSet);\n            }\n        }\n        return descriptor;\n    }\n    copyDescriptorIntoShadowTarget(shadowTarget, key) {\n        const { originalTarget } = this;\n        // Note: a property might get defined multiple times in the shadowTarget\n        //       but it will always be compatible with the previous descriptor\n        //       to preserve the object invariants, which makes these lines safe.\n        const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n        // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed\n        /* istanbul ignore else */\n        if (!isUndefined(originalDescriptor)) {\n            const wrappedDesc = this.wrapDescriptor(originalDescriptor);\n            ObjectDefineProperty(shadowTarget, key, wrappedDesc);\n        }\n    }\n    lockShadowTarget(shadowTarget) {\n        const { originalTarget } = this;\n        const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n        targetKeys.forEach((key) => {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        });\n        const { membrane: { tagPropertyKey } } = this;\n        if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));\n        }\n        preventExtensions(shadowTarget);\n    }\n    // Shared Traps\n    // TODO: apply() is never called\n    /* istanbul ignore next */\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    // TODO: construct() is never called\n    /* istanbul ignore next */\n    construct(shadowTarget, argArray, newTarget) {\n        /* No op */\n    }\n    get(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved } } = this;\n        const value = originalTarget[key];\n        valueObserved(originalTarget, key);\n        return this.wrapValue(value);\n    }\n    has(shadowTarget, key) {\n        const { originalTarget, membrane: { tagPropertyKey, valueObserved } } = this;\n        valueObserved(originalTarget, key);\n        // since key is never going to be undefined, and tagPropertyKey might be undefined\n        // we can simply compare them as the second part of the condition.\n        return key in originalTarget || key === tagPropertyKey;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget, membrane: { tagPropertyKey } } = this;\n        // if the membrane tag key exists and it is not in the original target, we add it to the keys.\n        const keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey) ? [] : [tagPropertyKey];\n        // small perf optimization using push instead of concat to avoid creating an extra array\n        ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));\n        ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));\n        return keys;\n    }\n    isExtensible(shadowTarget) {\n        const { originalTarget } = this;\n        // optimization to avoid attempting to lock down the shadowTarget multiple times\n        if (!isExtensible(shadowTarget)) {\n            return false; // was already locked down\n        }\n        if (!isExtensible(originalTarget)) {\n            this.lockShadowTarget(shadowTarget);\n            return false;\n        }\n        return true;\n    }\n    getPrototypeOf(shadowTarget) {\n        const { originalTarget } = this;\n        return getPrototypeOf(originalTarget);\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved, tagPropertyKey } } = this;\n        // keys looked up via getOwnPropertyDescriptor need to be reactive\n        valueObserved(originalTarget, key);\n        let desc = getOwnPropertyDescriptor(originalTarget, key);\n        if (isUndefined(desc)) {\n            if (key !== tagPropertyKey) {\n                return undefined;\n            }\n            // if the key is the membrane tag key, and is not in the original target,\n            // we produce a synthetic descriptor and install it on the shadow target\n            desc = { value: undefined, writable: false, configurable: false, enumerable: false };\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);\n            return desc;\n        }\n        if (desc.configurable === false) {\n            // updating the descriptor to non-configurable on the shadow\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        // Note: by accessing the descriptor, the key is marked as observed\n        // but access to the value, setter or getter (if available) cannot observe\n        // mutations, just like regular methods, in which case we just do nothing.\n        return this.wrapDescriptor(desc);\n    }\n}\n\nconst getterMap$1 = new WeakMap();\nconst setterMap$1 = new WeakMap();\nconst reverseGetterMap = new WeakMap();\nconst reverseSetterMap = new WeakMap();\nclass ReactiveProxyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap$1.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap(this)));\n        };\n        getterMap$1.set(originalGet, get);\n        reverseGetterMap.set(get, originalGet);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap$1.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const set = function (v) {\n            // invoking the original setter with the original target\n            originalSet.call(unwrap(this), unwrap(v));\n        };\n        setterMap$1.set(originalSet, set);\n        reverseSetterMap.set(set, originalSet);\n        return set;\n    }\n    unwrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            // dealing with a data descriptor\n            descriptor.value = unwrap(descriptor.value);\n        }\n        else {\n            const { set, get } = descriptor;\n            if (!isUndefined(get)) {\n                descriptor.get = this.unwrapGetter(get);\n            }\n            if (!isUndefined(set)) {\n                descriptor.set = this.unwrapSetter(set);\n            }\n        }\n        return descriptor;\n    }\n    unwrapGetter(redGet) {\n        const reverseGetter = reverseGetterMap.get(redGet);\n        if (!isUndefined(reverseGetter)) {\n            return reverseGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the red getter with the proxy of this\n            return unwrap(redGet.call(handler.wrapValue(this)));\n        };\n        getterMap$1.set(get, redGet);\n        reverseGetterMap.set(redGet, get);\n        return get;\n    }\n    unwrapSetter(redSet) {\n        const reverseSetter = reverseSetterMap.get(redSet);\n        if (!isUndefined(reverseSetter)) {\n            return reverseSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            // invoking the red setter with the proxy of this\n            redSet.call(handler.wrapValue(this), handler.wrapValue(v));\n        };\n        setterMap$1.set(set, redSet);\n        reverseSetterMap.set(redSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        const { originalTarget, membrane: { valueMutated } } = this;\n        const oldValue = originalTarget[key];\n        if (oldValue !== value) {\n            originalTarget[key] = value;\n            valueMutated(originalTarget, key);\n        }\n        else if (key === 'length' && isArray(originalTarget)) {\n            // fix for issue #236: push will add the new index, and by the time length\n            // is updated, the internal length is already equal to the new length value\n            // therefore, the oldValue is equal to the value. This is the forking logic\n            // to support this use case.\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n    deleteProperty(shadowTarget, key) {\n        const { originalTarget, membrane: { valueMutated } } = this;\n        delete originalTarget[key];\n        valueMutated(originalTarget, key);\n        return true;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        if (isExtensible(shadowTarget)) {\n            const { originalTarget } = this;\n            preventExtensions(originalTarget);\n            // if the originalTarget is a proxy itself, it might reject\n            // the preventExtension call, in which case we should not attempt to lock down\n            // the shadow target.\n            // TODO: It should not actually be possible to reach this `if` statement.\n            // If a proxy rejects extensions, then calling preventExtensions will throw an error:\n            // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY\n            /* istanbul ignore if */\n            if (isExtensible(originalTarget)) {\n                return false;\n            }\n            this.lockShadowTarget(shadowTarget);\n        }\n        return true;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        const { originalTarget, membrane: { valueMutated, tagPropertyKey } } = this;\n        if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {\n            // To avoid leaking the membrane tag property into the original target, we must\n            // be sure that the original target doesn't have yet.\n            // NOTE: we do not return false here because Object.freeze and equivalent operations\n            // will attempt to set the descriptor to the same value, and expect no to throw. This\n            // is an small compromise for the sake of not having to diff the descriptors.\n            return true;\n        }\n        ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));\n        // intentionally testing if false since it could be undefined as well\n        if (descriptor.configurable === false) {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        valueMutated(originalTarget, key);\n        return true;\n    }\n}\n\nconst getterMap = new WeakMap();\nconst setterMap = new WeakMap();\nclass ReadOnlyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getReadOnlyProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap(this)));\n        };\n        getterMap.set(originalGet, get);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n                const { originalTarget } = handler;\n                throw new Error(`Invalid mutation: Cannot invoke a setter on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n            }\n        };\n        setterMap.set(originalSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            const msg = isArray(originalTarget) ?\n                `Invalid mutation: Cannot mutate array at index ${key.toString()}. Array is read-only.` :\n                `Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`;\n            throw new Error(msg);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    deleteProperty(shadowTarget, key) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n}\n\nfunction extract(objectOrArray) {\n    if (isArray(objectOrArray)) {\n        return objectOrArray.map((item) => {\n            const original = unwrap(item);\n            if (original !== item) {\n                return extract(original);\n            }\n            return item;\n        });\n    }\n    const obj = ObjectCreate(getPrototypeOf(objectOrArray));\n    const names = getOwnPropertyNames(objectOrArray);\n    return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray))\n        .reduce((seed, key) => {\n        const item = objectOrArray[key];\n        const original = unwrap(item);\n        if (original !== item) {\n            seed[key] = extract(original);\n        }\n        else {\n            seed[key] = item;\n        }\n        return seed;\n    }, obj);\n}\nconst formatter = {\n    header: (plainOrProxy) => {\n        const originalTarget = unwrap(plainOrProxy);\n        // if originalTarget is falsy or not unwrappable, exit\n        if (!originalTarget || originalTarget === plainOrProxy) {\n            return null;\n        }\n        const obj = extract(plainOrProxy);\n        return ['object', { object: obj }];\n    },\n    hasBody: () => {\n        return false;\n    },\n    body: () => {\n        return null;\n    }\n};\n// Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n/* istanbul ignore next */\nfunction getGlobal() {\n    // the only reliable means to get the global object is `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    // Gracefully degrade if not able to locate the global object\n    return {};\n}\nfunction init() {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const global = getGlobal();\n    // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n    //  - Go to Settings,\n    //  - Under console, select \"Enable custom formatters\"\n    // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n    const devtoolsFormatters = global.devtoolsFormatters || [];\n    ArrayPush.call(devtoolsFormatters, formatter);\n    global.devtoolsFormatters = devtoolsFormatters;\n}\n\n/* istanbul ignore else */\nif (process.env.NODE_ENV !== 'production') {\n    init();\n}\nconst ObjectDotPrototype = Object.prototype;\nfunction defaultValueIsObservable(value) {\n    // intentionally checking for null\n    if (value === null) {\n        return false;\n    }\n    // treat all non-object types, including undefined, as non-observable values\n    if (typeof value !== 'object') {\n        return false;\n    }\n    if (isArray(value)) {\n        return true;\n    }\n    const proto = getPrototypeOf(value);\n    return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);\n}\nconst defaultValueObserved = (obj, key) => {\n    /* do nothing */\n};\nconst defaultValueMutated = (obj, key) => {\n    /* do nothing */\n};\nconst defaultValueDistortion = (value) => value;\nfunction createShadowTarget(value) {\n    return isArray(value) ? [] : {};\n}\nclass ReactiveMembrane {\n    constructor(options) {\n        this.valueDistortion = defaultValueDistortion;\n        this.valueMutated = defaultValueMutated;\n        this.valueObserved = defaultValueObserved;\n        this.valueIsObservable = defaultValueIsObservable;\n        this.readOnlyObjectGraph = new WeakMap();\n        this.reactiveObjectGraph = new WeakMap();\n        if (!isUndefined(options)) {\n            const { valueDistortion, valueMutated, valueObserved, valueIsObservable, tagPropertyKey } = options;\n            this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;\n            this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n            this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n            this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n            this.tagPropertyKey = tagPropertyKey;\n        }\n    }\n    getProxy(value) {\n        const unwrappedValue = unwrap(value);\n        const distorted = this.valueDistortion(unwrappedValue);\n        if (this.valueIsObservable(distorted)) {\n            if (this.readOnlyObjectGraph.get(distorted) === value) {\n                // when trying to extract the writable version of a readonly\n                // we return the readonly.\n                return value;\n            }\n            return this.getReactiveHandler(unwrappedValue, distorted);\n        }\n        return distorted;\n    }\n    getReadOnlyProxy(value) {\n        value = unwrap(value);\n        const distorted = this.valueDistortion(value);\n        if (this.valueIsObservable(distorted)) {\n            return this.getReadOnlyHandler(value, distorted);\n        }\n        return distorted;\n    }\n    unwrapProxy(p) {\n        return unwrap(p);\n    }\n    getReactiveHandler(value, distortedValue) {\n        let proxy = this.reactiveObjectGraph.get(distortedValue);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReactiveProxyHandler(this, distortedValue);\n            proxy = new Proxy(createShadowTarget(distortedValue), handler);\n            registerProxy(proxy, value);\n            this.reactiveObjectGraph.set(distortedValue, proxy);\n        }\n        return proxy;\n    }\n    getReadOnlyHandler(value, distortedValue) {\n        let proxy = this.readOnlyObjectGraph.get(distortedValue);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReadOnlyHandler(this, distortedValue);\n            proxy = new Proxy(createShadowTarget(distortedValue), handler);\n            registerProxy(proxy, value);\n            this.readOnlyObjectGraph.set(distortedValue, proxy);\n        }\n        return proxy;\n    }\n}\n\nexport { ReactiveMembrane as default };\n/** version: 1.1.5 */\n","import ObservableMembrane from 'observable-membrane'\n\nexport function wrap(data, mutationCallback) {\n    /* IE11-ONLY:START */\n    // return wrapForIe11(data, mutationCallback)\n    /* IE11-ONLY:END */\n\n\n    let membrane = new ObservableMembrane({\n        valueMutated(target, key) {\n            mutationCallback(target, key)\n        },\n    })\n\n    return {\n        data: membrane.getProxy(data),\n        membrane: membrane,\n    }\n}\n\nexport function unwrap(membrane, observable) {\n    let unwrappedData = membrane.unwrapProxy(observable)\n    let copy = {}\n\n    Object.keys(unwrappedData).forEach(key => {\n        if (['$el', '$refs', '$nextTick', '$watch', '$jmb'].includes(key)) return\n\n        copy[key] = unwrappedData[key]\n    })\n\n    return copy\n}\n\n// function wrapForIe11(data, mutationCallback) {\n//     const proxyHandler = {\n//         set(target, key, value) {\n//             // Set the value converting it to a \"Deep Proxy\" when required\n//             // Note that if a project is not a valid object, it won't be converted to a proxy\n//             const setWasSuccessful = Reflect.set(target, key, deepProxy(value, proxyHandler))\n\n//             mutationCallback(target, key)\n\n//             return setWasSuccessful\n//         },\n//         get(target, key) {\n//             // Provide a way to determine if this object is an Alpine proxy or not.\n//             if (key === \"$isAlpineProxy\") return true\n\n//             // Just return the flippin' value. Gawsh.\n//             return target[key]\n//         }\n//     }\n\n//     return {\n//         data: deepProxy(data, proxyHandler),\n//         membrane: {\n//             unwrapProxy(proxy) {\n//                 return proxy\n//             }\n//         },\n//     }\n// }\n\n// function deepProxy(target, proxyHandler) {\n//     // If target is null, return it.\n//     if (target === null) return target;\n\n//     // If target is not an object, return it.\n//     if (typeof target !== 'object') return target;\n\n//     // If target is a DOM node (like in the case of this.$el), return it.\n//     if (target instanceof Node) return target\n\n//     // If target is already an Alpine proxy, return it.\n//     if (target['$isAlpineProxy']) return target;\n\n//     // Otherwise proxy the properties recursively.\n//     // This enables reactivity on setting nested data.\n//     // Note that if a project is not a valid object, it won't be converted to a proxy\n//     for (let property in target) {\n//         target[property] = deepProxy(target[property], proxyHandler)\n//     }\n\n//     return new Proxy(target, proxyHandler)\n// }\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","import { isAbsolute, join } from \"path\";\nexport default class JMB {\n  constructor(jembeClient, execName) {\n    this.jembeClient = jembeClient\n    this.execName = execName\n    this.callsCommands = false\n  }\n  call(actionName, ...params) {\n    this.callsCommands = true\n\n    let kwargs = {}\n    let args = []\n    if (params.length === 1 && params[0].constructor == Object) {\n      kwargs = params[0]\n    } else {\n      args = params\n    }\n    this.jembeClient.addCallCommand(\n      this.execName,\n      actionName,\n      args,\n      kwargs\n    )\n  }\n  display() {\n    this.call(\"display\")\n  }\n  /**\n   *  Change state param of current component,\n   *  by addig initialise command with only state param \n   *  defined by stateName changed to newlly provided value\n   * stateName can use dots (.) to set attribure of object\n   * Examples: \"someObject.paramName\" \n   * @param {string} stateName \n   * @param {*} value \n   */\n  set(stateName, value) {\n    this.callsCommands = true\n    if (value instanceof FileList || value instanceof File) {\n      this.jembeClient.addFilesForUpload(this.execName, stateName, value)\n    } else {\n      let params = {}\n      params[stateName] = value\n      this.jembeClient.addInitialiseCommand(\n        this.execName,\n        params\n      )\n    }\n  }\n  emit(eventName, kwargs = {}, to = null) {\n    this.callsCommands = true\n    this.jembeClient.addEmitCommand(\n      this.execName,\n      eventName,\n      kwargs,\n      to\n    )\n  }\n  component(relativeExecName, kwargs = {}, mergeExistingParams = true) {\n    this.callsCommands = true\n\n    let execName = relativeExecName\n    if (!isAbsolute(relativeExecName)) {\n      execName = join(this.execName, relativeExecName)\n    }\n    let componentNames = []\n    let startWith = []\n    let index = 0\n    let equalSoFar = true\n    let execNameSplit = execName.split(\"/\")\n    let thisExecNameSplit = this.execName.split(\"/\")\n    while (index < execNameSplit.length) {\n      if (equalSoFar === true &&\n        (\n          // if execName is different (including key) we need to genereate init command\n          execNameSplit[index] !== thisExecNameSplit[index] ||\n          // alsy if kwargs are specified for last component we need do generate init command\n          (index === execNameSplit.length - 1 && kwargs !== {})\n        )\n      ) {\n        equalSoFar = false\n      }\n      if (!equalSoFar) {\n        componentNames.push(execNameSplit[index])\n      } else {\n        startWith.push(execNameSplit[index])\n      }\n      index++\n    }\n\n    index = 0\n    while (index < componentNames.length) {\n      this.jembeClient.addInitialiseCommand(\n        [\n          startWith.join(\"/\"),\n          componentNames.slice(0, index + 1).join(\"/\")\n        ].join(\"/\"),\n        index == componentNames.length - 1 ? kwargs : {},\n        mergeExistingParams\n      )\n      index++\n    }\n    return new JMB(this.jembeClient, execName)\n  }\n  component_reset(relativeExecName, kwargs = {}) {\n    return this.component(relativeExecName, kwargs, false)\n  }\n  executeCommands(disableInputs=true) {\n    this.jembeClient.executeCommands(disableInputs)\n  }\n  componentsOnPage(filter) {\n    if (filter === undefined) {\n      return Object.keys(this.jembeClient.components)\n    } else {\n      return Object.values(this.jembeClient.components).filter(filter).map(c => c.execName)\n    }\n  }\n}","/**\n * Havily modified alpine.js 2.8.1 to:\n *  - user 'jmb-' instead 'x-' as prefix\n *  - jembe component becomes alpine component\n *  - jembe component state params and actions becomes alpine jmb-data params and actions\n *  - when jembe state params are changed or action is called in jmb-data,\n *     call appropriate function on jembeclient\n *  - support local variables accessible only in alpine componetn with jmb-local,\n *    jmb-init, jmb-update directives\n *  - alpine/copmonentapi local variables are accessible with $local prefix\n *  - $node references current node on witch action is executed (jmb-on etc.)\n *  - add $jmb magic variable to reference jembeClient.component(this) to access set, cal display emit and init commands\n *  - when componentApi action changes any state variable are call any jembe action jembeClient.executeCommands() will be called\n *    if there is not defer modifier\n *  \n * modification are enclosed with @jembeModification\n */\nimport { walk, saferEval, saferEvalNoReturn, getXAttrs, debounce, convertClassStringToArray, TRANSITION_CANCELLED } from './utils'\nimport { handleForDirective } from './directives/for'\nimport { handleAttributeBindingDirective } from './directives/bind'\nimport { handleTextDirective } from './directives/text'\nimport { handleHtmlDirective } from './directives/html'\nimport { handleShowDirective } from './directives/show'\nimport { handleIfDirective } from './directives/if'\nimport { registerModelListener } from './directives/model'\nimport { registerListener } from './directives/on'\nimport { unwrap, wrap } from './observable'\n// import Alpine from './index'\nimport JMB from './magic/jmb'\n\nexport default class Component {\n    // @jembeModification\n    // constructor is separated in constructor + mount and havily modified to support\n    // jembeComponents\n    // mount do actual initialisation of component cunstructor don't do anything\n    constructor(el) {\n        this.$el = el\n\n        this.mounted = false\n        this.jembeClient = undefined\n        this.execName = undefined\n        this.state = undefined\n        this.actions = undefined\n        this.unnamedTimers = []\n        this.namedTimers = {}\n        this.originalComponentNamedTimers = {}\n        this.mutationObserver = undefined\n\n        // this.elWithScopes = []\n    }\n    /**\n     * @param {Component} originalComponent \n     */\n    mount(jembeClient, execName, state, actions, originalComponent = undefined) {\n        if (this.mounted\n            && (\n                this.jembeClient !== jembeClient\n                || this.execName !== execName\n            )) {\n            throw (`Mounting ComponetApi for new component: ${this.execName} -> ${execName}`)\n        } else {\n            this.mounted = true\n\n            this.jembeClient = jembeClient\n            this.execName = execName\n            this.$jmb = new JMB(this.jembeClient, this.execName)\n        }\n        if (originalComponent !== undefined) {\n            this.originalComponentNamedTimers = originalComponent.namedTimers\n        }\n        var self = this\n        this.$updateDom = debounce(function () {\n            self.updateElements(self.$el)\n        }, 0)\n\n\n        this.state = JSON.parse(JSON.stringify(state));\n        this.actions = actions\n\n        for (const stateName of Object.keys(this.state)) {\n            if (Object.keys(this.actions).includes(stateName)) {\n                console.warn(`state param '${stateName}' overrides action with same name in component ${this.execName}!`)\n            }\n        }\n\n        const localAttr = this.$el.getAttribute('jmb-local')\n        const localExpression = (localAttr === '' || localAttr === null) ? '{}' : localAttr\n        const initAttr = this.$el.getAttribute('jmb-init')\n        const initExpression = (initAttr === '' || initAttr === null) ? '{}' : initAttr\n        const updateAttr = this.$el.getAttribute('jmb-update')\n        const updateExpression = (updateAttr === '' || updateAttr === null) ? '{}' : updateAttr\n        let dataExtras = {\n            $el: this.$el,\n            $jmb: this.$jmb,\n        }\n\n        let canonicalComponentElementReference = this.$el\n\n        // Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        //     Object.defineProperty(dataExtras, `$${name}`, { get: function () { return callback(canonicalComponentElementReference) } });\n        // })\n        // add local\n        this.unobservedData = {\n            $local: (originalComponent === undefined)\n                ? saferEval(this.$el, localExpression, dataExtras)\n                : originalComponent.getUnobservedData()['$local']\n        }\n        // add actions\n        Object.entries(this.actions).forEach(([actionName, actionEnabled]) => {\n            Object.defineProperty(\n                this.unobservedData,\n                `${actionName}`,\n                { get: function () { return (...params) => { this.$jmb.call(actionName, ...params) } } }\n            )\n        })\n        // add states\n        Object.entries(this.state).forEach(([name, value]) => {\n            this.unobservedData[name] = value\n        })\n        // TODO add watcher to state data and fire init commands accoringly\n\n        /* IE11-ONLY:START */\n        // For IE11, add our magic properties to the original data for access.\n        // The Proxy polyfill does not allow properties to be added after creation.\n        // this.unobservedData.$el = null\n        // this.unobservedData.$refs = null\n        // this.unobservedData.$nextTick = null\n        // this.unobservedData.$watch = null\n        // this.unobservedData.$jmb = null\n        // The IE build uses a proxy polyfill which doesn't allow properties\n        // to be defined after the proxy object is created so,\n        // for IE only, we need to define our helpers earlier.\n        // Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        //     Object.defineProperty(this.unobservedData, `$${name}`, { get: function () { return callback(canonicalComponentElementReference, this.$el) } });\n        // })\n        /* IE11-ONLY:END */\n\n        // Construct a Proxy-based observable. This will be used to handle reactivity.\n        let { membrane, data } = this.wrapDataInObservable(this.unobservedData)\n        this.$data = data\n        this.membrane = membrane\n\n        // After making user-supplied data methods reactive, we can now add\n        // our magic properties to the original data for access.\n        this.unobservedData.$el = this.$el\n        this.unobservedData.$refs = this.getRefsProxy()\n        this.unobservedData.$jmb = this.$jmb\n        this.unobservedData.$updateDom = this.$updateDom\n        this.unobservedData.$context = this.$data\n\n        this.nextTickStack = []\n        this.unobservedData.$nextTick = (callback) => {\n            this.nextTickStack.push(callback)\n        }\n\n        this.watchers = originalComponent !== undefined ? originalComponent.watchers : {}\n        this.unobservedData.$watch = (property, callback) => {\n            if (!this.watchers[property]) this.watchers[property] = []\n            this.watchers[property].push(callback)\n        }\n\n\n        /* MODERN-ONLY:START */\n        // We remove this piece of code from the legacy build.\n        // In IE11, we have already defined our helpers at this point.\n\n        // Register custom magic properties.\n        // Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        //     Object.defineProperty(this.unobservedData, `$${name}`, { get: function () { return callback(canonicalComponentElementReference, this.$el) } });\n        // })\n        /* MODERN-ONLY:END */\n\n        this.showDirectiveStack = []\n        this.showDirectiveLastElement\n\n        // Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this))\n\n        var initReturnedCallback\n        // If jmb-init is present AND we aren't cloning (skip jmb-init on clone)\n        if (originalComponent === undefined && initExpression) {\n            // We want to allow data manipulation, but not trigger DOM updates just yet.\n            // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.\n            this.pauseReactivity = true\n            initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression)\n            this.pauseReactivity = false\n        } else if (originalComponent !== undefined && updateExpression) {\n            this.pauseReactivity = true\n            initReturnedCallback = this.evaluateReturnExpression(this.$el, updateExpression)\n            this.pauseReactivity = false\n        }\n\n        // Register all our listeners and set all our attribute bindings.\n        // If we're cloning a component, the third parameter ensures no duplicate\n        // event listeners are registered (the mutation observer will take care of them)\n        // this.initializeElements(this.$el, () => { }, originalComponent === undefined)\n        this.initializeElements(this.$el, () => { }, originalComponent !== undefined)\n\n        // Use mutation observer to detect new elements being added within this component at run-time.\n        // Alpine's just so darn flexible amirite?\n        this.mutationObserver = this.listenForNewElementsToInitialize()\n\n        if (typeof initReturnedCallback === 'function') {\n            // Run the callback returned from the \"jmb-init\" hook to allow the user to do stuff after\n            // Alpine's got it's grubby little paws all over everything.\n            initReturnedCallback.call(this.$data)\n        }\n\n        // setTimeout(() => {\n        //     Alpine.onComponentInitializeds.forEach(callback => callback(this))\n        // }, 0)\n    }\n    unmount() {\n        for (const timerId of this.unnamedTimers) {\n            window.clearTimeout(timerId)\n        }\n        for (const [timerName, timerInfo] of Object.entries(this.namedTimers)) {\n            window.clearTimeout(timerInfo.id)\n        }\n        this.mutationObserver.disconnect()\n        this.mutationObserver = undefined\n        // // remove scopes\n        // for (const scope_el of this.elWithScopes) {\n        //     scope_el.__jmb_scope = undefined\n        // }\n        // console.log('unmounted')\n        // this.elWithScopes = []\n    }\n    getUnobservedData() {\n        return unwrap(this.membrane, this.$data)\n    }\n\n    findTargetPathInData(tree, target, key = \"\", level = 0) {\n        if (Object.is(tree, target)) {\n            return key\n        }\n        const treeIsArray = Array.isArray(tree)\n        for (const [name, value] of Object.entries(tree)) {\n            if (!((level === 0 && name.startsWith('$')) || (treeIsArray && name === 'length')) && typeof value === \"object\" && value !== null) {\n                const subpath = this.findTargetPathInData(value, target, name, level + 1)\n                if (subpath !== undefined) {\n                    return key !== \"\" ? `${key}.${subpath}` : subpath\n                }\n            }\n        }\n    }\n    wrapDataInObservable(data) {\n        var self = this\n        \n        let updateDom = debounce(function () {\n            self.updateElements(self.$el)\n        }, 0)\n\n        return wrap(data, (target, key) => {\n            // check if is state variable by compoaring target\n            let path = this.findTargetPathInData(this.unobservedData, target)\n            if (path !== undefined) {\n                this.$jmb.set(path === \"\" ? key : `${path}.${key}`, target[key])\n            }\n            if (Object.is(target, this.unobservedData) && Object.keys(this.state).includes(key)) {\n                this.$jmb.set(key, target[key])\n            }\n            if (self.watchers[key]) {\n                // If there's a watcher for this specific key, run it.\n                self.watchers[key].forEach(callback => callback(target[key]))\n            } else if (Array.isArray(target)) {\n                // Arrays are special cases, if any of the items change, we consider the array as mutated.\n                Object.keys(self.watchers)\n                    .forEach(fullDotNotationKey => {\n                        let dotNotationParts = fullDotNotationKey.split('.')\n\n                        // Ignore length mutations since they would result in duplicate calls.\n                        // For example, when calling push, we would get a mutation for the item's key\n                        // and a second mutation for the length property.\n                        if (key === 'length') return\n\n                        dotNotationParts.reduce((comparisonData, part) => {\n                            if (Object.is(target, comparisonData[part])) {\n                                self.watchers[fullDotNotationKey].forEach(callback => callback(target))\n                            }\n\n                            return comparisonData[part]\n                        }, self.unobservedData)\n                    })\n            } else {\n                // Let's walk through the watchers with \"dot-notation\" (foo.bar) and see\n                // if this mutation fits any of them.\n                Object.keys(self.watchers)\n                    .filter(i => i.includes('.'))\n                    .forEach(fullDotNotationKey => {\n                        let dotNotationParts = fullDotNotationKey.split('.')\n\n                        // If this dot-notation watcher's last \"part\" doesn't match the current\n                        // key, then skip it early for performance reasons.\n                        if (key !== dotNotationParts[dotNotationParts.length - 1]) return\n\n                        // Now, walk through the dot-notation \"parts\" recursively to find\n                        // a match, and call the watcher if one's found.\n                        dotNotationParts.reduce((comparisonData, part) => {\n                            if (Object.is(target, comparisonData)) {\n                                // Run the watchers.\n                                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]))\n                            }\n\n                            return comparisonData[part]\n                        }, self.unobservedData)\n                    })\n            }\n\n            // Don't react to data changes for cases like the `jmb-created` hook.\n            if (self.pauseReactivity) return\n\n            updateDom()\n        })\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => { }) {\n        walk(el, el => {\n            // We've hit a component.\n            if (el.hasAttribute('jmb-name') || el.hasAttribute('jmb-placeholder')) {\n                // If it's not the current one.\n                if (!el.isSameNode(this.$el)) {\n                    // Initialize it if it's not.\n                    if (!el.__jmb) initializeComponentCallback(el)\n\n                    // Now we'll let that sub-component deal with itself.\n                    return false\n                }\n            }\n\n            return callback(el)\n        })\n    }\n\n    initializeElements(rootEl, extraVars = () => { }, mutated = false) {\n        this.walkAndSkipNestedComponents(rootEl, el => {\n            // Don't touch spawns from for loop\n            if (el.__jmb_for_key !== undefined) return false\n\n            // Don't touch spawns from if directives\n            if (el.__jmb_inserted_me !== undefined) return false\n\n            this.initializeElement(el, extraVars, mutated)\n        }, el => {\n            el.__jmb = new Component(el)\n        })\n\n        this.executeAndClearRemainingShowDirectiveStack()\n\n        this.executeAndClearNextTickStack(rootEl)\n    }\n\n    initializeElement(el, extraVars, mutated = false) {\n        // To support class attribute merging, we have to know what the element's\n        // original class attribute looked like for reference.\n        if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {\n            el.__jmb_original_classes = convertClassStringToArray(el.getAttribute('class'))\n        }\n        // remove all existing listeners\n        if (el.__jmb_listeners !== undefined) {\n            for (const [ltarget, event, handler, options] of el.__jmb_listeners) {\n                ltarget.removeEventListener(event, handler, options)\n            }\n            el.__jmb_listeners = undefined\n        }\n        if (el.__jmb_scope !== undefined && !el.hasAttribute('jmb-scope')) {\n            el.__jmb_scope = undefined\n        }\n        this.registerListeners(el, extraVars, mutated)\n        this.resolveBoundAttributes(el, true, extraVars)\n    }\n\n    updateElements(rootEl, extraVars = () => { }) {\n        this.walkAndSkipNestedComponents(rootEl, el => {\n            // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)\n            if (el.__jmb_for_key !== undefined && !el.isSameNode(this.$el)) return false\n\n            this.updateElement(el, extraVars)\n        }, el => {\n            el.__jmb = new Component(el)\n        })\n\n        this.executeAndClearRemainingShowDirectiveStack()\n\n        this.executeAndClearNextTickStack(rootEl)\n    }\n\n    executeAndClearNextTickStack(el) {\n        // Skip spawns from alpine directives\n        if (el === this.$el && this.nextTickStack.length > 0) {\n            // We run the tick stack after the next frame to allow any\n            // running transitions to pass the initial show stage.\n            requestAnimationFrame(() => {\n                while (this.nextTickStack.length > 0) {\n                    this.nextTickStack.shift()()\n                }\n            })\n        }\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n        // The goal here is to start all the jmb-show transitions\n        // and build a nested promise chain so that elements\n        // only hide when the children are finished hiding.\n        this.showDirectiveStack.reverse().map(handler => {\n            return new Promise((resolve, reject) => {\n                handler(resolve, reject)\n            })\n        }).reduce((promiseChain, promise) => {\n            return promiseChain.then(() => {\n                return promise.then(finishElement => {\n                    finishElement()\n                })\n            })\n        }, Promise.resolve(() => { })).catch(e => {\n            if (e !== TRANSITION_CANCELLED) throw e\n        })\n\n        // We've processed the handler stack. let's clear it.\n        this.showDirectiveStack = []\n        this.showDirectiveLastElement = undefined\n    }\n\n    updateElement(el, extraVars) {\n        this.resolveBoundAttributes(el, false, extraVars)\n    }\n\n    registerListeners(el, extraVars, mutated) {\n        getXAttrs(el, this).forEach(({ type, value, modifiers, expression }) => {\n            switch (type) {\n                case 'on':\n                    registerListener(this, el, value, modifiers, expression, extraVars, mutated)\n                    break;\n\n                case 'model':\n                    registerModelListener(this, el, modifiers, expression, extraVars)\n                    break;\n                default:\n                    break;\n            }\n        })\n    }\n\n    resolveBoundAttributes(el, initialUpdate = false, extraVars) {\n        let attrs = getXAttrs(el, this)\n        attrs.forEach(({ type, value, modifiers, expression }) => {\n            switch (type) {\n                case 'model':\n                    handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers)\n                    break;\n\n                case 'bind':\n                    // The :key binding on an jmb-for is special, ignore it.\n                    if (el.tagName.toLowerCase() === 'template' && value === 'key') return\n\n                    handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers)\n                    break;\n\n                case 'text':\n                    var output = this.evaluateReturnExpression(el, expression, extraVars);\n\n                    handleTextDirective(el, output, expression)\n                    break;\n\n                case 'html':\n                    handleHtmlDirective(this, el, expression, extraVars)\n                    break;\n\n                case 'show':\n                    var output = this.evaluateReturnExpression(el, expression, extraVars)\n\n                    handleShowDirective(this, el, output, modifiers, initialUpdate)\n                    break;\n\n                case 'if':\n                    // If this element also has jmb-for on it, don't process jmb-if.\n                    // We will let the \"jmb-for\" directive handle the \"if\"ing.\n                    if (attrs.some(i => i.type === 'for')) return\n\n                    var output = this.evaluateReturnExpression(el, expression, extraVars)\n\n                    handleIfDirective(this, el, output, initialUpdate, extraVars)\n                    break;\n\n                case 'for':\n                    handleForDirective(this, el, expression, initialUpdate, extraVars)\n                    break;\n\n                case 'cloak':\n                    el.removeAttribute('jmb-cloak')\n                    break;\n                // case 'scope':\n                //     if (el.__jmb_scope === undefined) {\n                //         this.$updateDom()\n                //     }\n                //     break;\n\n                default:\n                    break;\n            }\n        })\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => { }) {\n        let self = this\n        let extVars = extraVars()\n        let self_el = extVars !== undefined && extVars.$self !== undefined ? extVars.$self : el\n        return saferEval(el, expression, this.$data, {\n            $self: el,\n            ...extVars,\n            $dispatch: this.getDispatchFunction(el),\n            $scope: () => { return self.getScopeVars(self_el) }\n        })\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => { }) {\n        let self = this\n        let extVars = extraVars()\n        let self_el = extVars !== undefined && extVars.$self !== undefined ? extVars.$self : el\n        return saferEvalNoReturn(el, expression, this.$data, {\n            $self: el,\n            ...extVars,\n            $dispatch: this.getDispatchFunction(el),\n            $scope: () => { return self.getScopeVars(self_el) }\n        })\n    }\n\n    getDispatchFunction(el) {\n        return (event, detail = {}) => {\n            el.dispatchEvent(new CustomEvent(event, {\n                detail,\n                bubbles: true,\n            }))\n        }\n    }\n\n    listenForNewElementsToInitialize() {\n        const targetNode = this.$el\n\n        const observerOptions = {\n            childList: true,\n            attributes: true,\n            subtree: true,\n        }\n\n        const observer = new MutationObserver((mutations) => {\n            for (let i = 0; i < mutations.length; i++) {\n                // Filter out mutations triggered from child components.\n                const closestParentComponent = mutations[i].target.closest('[jmb-name]')\n\n                if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue\n\n                if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'jmb-local') {\n                    // @jembeModification\n                    // do nothing jmb-local on subsequent update should be ignore and jmb-update shold be used\n                    // const xAttr = mutations[i].target.getAttribute('jmb-local') || '{}';\n                    // const rawData = saferEval(this.$el, xAttr, { $el: this.$el })\n\n                    // Object.keys(rawData).forEach(key => {\n                    //     if (this.$data[key] !== rawData[key]) {\n                    //         this.$data[key] = rawData[key]\n                    //     }\n                    // })\n                }\n\n                if (mutations[i].addedNodes.length > 0) {\n                    mutations[i].addedNodes.forEach(node => {\n                        if (node.nodeType !== 1 || node.__jmb_inserted_me) return\n                        if ((node.hasAttribute('jmb-name') && node.getAttribute('jmb-name') !== this.execName) || node.hasAttribute('jmb-placeholder')) return\n\n                        // @jembeModification\n                        // can only create component for jembe component it ignores jmb-local on\n                        // other components\n                        // if (node.matches('[jmb-local]') && !node.__jmb) {\n                        //     node.__jmb = new Component(node)\n                        //     return\n                        // }\n                        this.initializeElement(node, () => { }, true)\n                    })\n                }\n            }\n        })\n\n        observer.observe(targetNode, observerOptions);\n        return observer;\n    }\n\n    getRefsProxy() {\n        var self = this\n\n        var refObj = {}\n\n        /* IE11-ONLY:START */\n        // // Add any properties up-front that might be necessary for the Proxy polyfill.\n        // refObj.$isRefsProxy = false;\n        // refObj.$isAlpineProxy = false;\n\n        // // If we are in IE, since the polyfill needs all properties to be defined before building the proxy,\n        // // we just loop on the element, look for any jmb-ref and create a tmp property on a fake object.\n        // this.walkAndSkipNestedComponents(self.$el, el => {\n        //     if (el.hasAttribute('jmb-ref')) {\n        //         refObj[el.getAttribute('jmb-ref')] = true\n        //     }\n        // })\n        /* IE11-ONLY:END */\n\n        // One of the goals of this is to not hold elements in memory, but rather re-evaluate\n        // the DOM when the system needs something from it. This way, the framework is flexible and\n        // friendly to outside DOM changes from libraries like Vue/Livewire.\n        // For this reason, I'm using an \"on-demand\" proxy to fake a \"$refs\" object.\n        return new Proxy(refObj, {\n            get(object, property) {\n                if (property === '$isAlpineProxy') return true\n\n                var ref\n\n                // We can't just query the DOM because it's hard to filter out refs in\n                // nested components.\n                self.walkAndSkipNestedComponents(self.$el, el => {\n                    if (el.hasAttribute('jmb-ref') && el.getAttribute('jmb-ref') === property) {\n                        ref = el\n                    }\n                })\n\n                return ref\n            }\n        })\n    }\n    getScopeVars(el) {\n        let self = this\n        if (el === window) {\n            return {}\n        }\n        let scope_el = null\n        if (el.hasAttribute('jmb-scope')) {\n            scope_el = el\n        } else {\n            let cs = el.closest('[jmb-scope]')\n            if (cs !== null) {\n                let jc = cs.closest('[jmb-name]')\n                if (jc !== null && jc.getAttribute('jmb-name') === self.execName) {\n                    scope_el = cs\n                }\n            }\n        }\n        if (scope_el !== null) {\n            if (scope_el.__jmb_scope === undefined) {\n                scope_el.__jmb_scope = this.evaluateReturnExpression(scope_el, scope_el.getAttribute('jmb-scope'))\n                // this.elWithScopes.push(scope_el)\n            }\n            let { membrane, data } = wrap(scope_el.__jmb_scope, (target, key) => {\n                self.$updateDom()\n            })\n            return data\n        }\n        return {}\n    }\n}\n","import Component from './component'\nimport { domReady, isTesting } from './utils'\n\nclass ComponentAPI extends Component {\n  /**\n   * @param {ComponentRef} componentRef \n   */\n  constructor(componentRef) {\n    super(componentRef.dom)\n    this.jembeClient = componentRef.jembeClient\n    this.componentRef = componentRef\n    this.execName = componentRef.execName\n  }\n  /**\n   * @param {ComponentRef} originalComponentRef \n   */\n  mount(originalComponentRef) {\n    super.mount(\n      this.componentRef.jembeClient,\n      this.componentRef.execName,\n      this.componentRef.state,\n      this.componentRef.actions,\n      (originalComponentRef !== undefined \n        && originalComponentRef.api !== null\n        // TODO handle page component with diferent execName`s\n        && originalComponentRef.execName === this.execName)\n        ? originalComponentRef.api\n        : undefined)\n  }\n  unmount() { \n    super.unmount()\n  }\n}\nexport default ComponentAPI\n\n// const Alpine = {\n//     version: process.env.PKG_VERSION,\n\n//     pauseMutationObserver: false,\n\n//     magicProperties: {},\n\n//     onComponentInitializeds: [],\n\n//     onBeforeComponentInitializeds: [],\n\n//     ignoreFocusedForValueBinding: false,\n\n//     start: async function () {\n//         if (! isTesting()) {\n//             await domReady()\n//         }\n\n//         this.discoverComponents(el => {\n//             this.initializeComponent(el)\n//         })\n\n//         // It's easier and more performant to just support Turbolinks than listen\n//         // to MutationObserver mutations at the document level.\n//         document.addEventListener(\"turbolinks:load\", () => {\n//             this.discoverUninitializedComponents(el => {\n//                 this.initializeComponent(el)\n//             })\n//         })\n\n//         this.listenForNewUninitializedComponentsAtRunTime()\n//     },\n\n//     discoverComponents: function (callback) {\n//         const rootEls = document.querySelectorAll('[x-data]');\n\n//         rootEls.forEach(rootEl => {\n//             callback(rootEl)\n//         })\n//     },\n\n//     discoverUninitializedComponents: function (callback, el = null) {\n//         const rootEls = (el || document).querySelectorAll('[jmb-data]');\n\n//         Array.from(rootEls)\n//             .filter(el => el.__jmb === undefined)\n//             .forEach(rootEl => {\n//                 callback(rootEl)\n//             })\n//     },\n\n//     listenForNewUninitializedComponentsAtRunTime: function () {\n//         const targetNode = document.querySelector('body');\n\n//         const observerOptions = {\n//             childList: true,\n//             attributes: true,\n//             subtree: true,\n//         }\n\n//         const observer = new MutationObserver((mutations) => {\n//             if (this.pauseMutationObserver) return;\n\n//             for (let i=0; i < mutations.length; i++){\n//                 if (mutations[i].addedNodes.length > 0) {\n//                     mutations[i].addedNodes.forEach(node => {\n//                         // Discard non-element nodes (like line-breaks)\n//                         if (node.nodeType !== 1) return\n\n//                         // Discard any changes happening within an existing component.\n//                         // They will take care of themselves.\n//                         if (node.parentElement && node.parentElement.closest('[x-data]')) return\n\n//                         this.discoverUninitializedComponents((el) => {\n//                             this.initializeComponent(el)\n//                         }, node.parentElement)\n//                     })\n//                 }\n//               }\n//         })\n\n//         observer.observe(targetNode, observerOptions)\n//     },\n\n//     initializeComponent: function (el) {\n//         if (! el.__jmb) {\n//             // Wrap in a try/catch so that we don't prevent other components\n//             // from initializing when one component contains an error.\n//             try {\n//                 el.__jmb = new Component(el)\n//             } catch (error) {\n//                 setTimeout(() => {\n//                     throw error\n//                 }, 0)\n//             }\n//         }\n//     },\n\n//     clone: function (component, newEl) {\n//         if (! newEl.__jmb) {\n//             newEl.__jmb = new Component(newEl, component)\n//         }\n//     },\n\n//     addMagicProperty: function (name, callback) {\n//         this.magicProperties[name] = callback\n//     },\n\n//     onComponentInitialized: function (callback) {\n//         this.onComponentInitializeds.push(callback)\n//     },\n\n//     onBeforeComponentInitialized: function (callback) {\n//         this.onBeforeComponentInitializeds.push(callback)\n//     }\n// }\n\n// if (! isTesting()) {\n//     window.Alpine = Alpine\n\n//     if (window.deferLoadingAlpine) {\n//         window.deferLoadingAlpine(function () {\n//             window.Alpine.start()\n//         })\n//    } else {\n//         window.Alpine.start()\n//    }\n// }\n\n// export default Alpine\n","/**\n * Return null or the execName of the component \n * @param {Element} el \n */\nfunction elIsNewComponent(el) {\n  if (el.hasAttribute('jmb-name')) {\n    return el.getAttribute('jmb-name')\n  } else if (el.hasAttribute('jmb-placeholder')) {\n    return el.getAttribute('jmb-placeholder')\n  } else {\n    return null\n  }\n}\n\nfunction walkComponentDom(el, callback, callbackOnNewComponent, myExecName) {\n  if (myExecName === undefined) {\n    myExecName = el.getAttribute('jmb-name')\n  }\n  let componentExecName = elIsNewComponent(el)\n  if (componentExecName !== null && componentExecName !== myExecName) {\n    if (callbackOnNewComponent !== undefined && callbackOnNewComponent !== null) {\n      callbackOnNewComponent(el, componentExecName)\n    }\n  } else {\n    if (callback !== undefined) {\n      callback(el)\n    }\n    el = el.firstElementChild\n    while (el) {\n      walkComponentDom(el, callback, callbackOnNewComponent, myExecName)\n      el = el.nextElementSibling\n    }\n  }\n}\n\nlet AsyncFunction = Object.getPrototypeOf(async function () { }).constructor\n\n\nfunction deepCopy(inObject) {\n  let outObject, value, key\n\n  if (typeof inObject !== \"object\" || inObject === null) {\n    return inObject // Return the value if inObject is not an object\n  }\n\n  // Create an array or object to hold the values\n  outObject = Array.isArray(inObject) ? [] : {}\n\n  for (key in inObject) {\n    value = inObject[key]\n\n    // Recursively (deep) copy for nested objects, including arrays\n    outObject[key] = deepCopy(value)\n  }\n\n  return outObject\n}\n/**\n * https://docs.djangoproject.com/en/dev/ref/csrf/#ajax\n */\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\nexport { walkComponentDom, AsyncFunction, deepCopy, getCookie }","var DOCUMENT_FRAGMENT_NODE = 11;\n\nexport default function morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n","var range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nexport var doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nexport function toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nexport function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nexport function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nexport function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n","function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nexport default {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\n/**\n * Changes taged with @jembeModification\n * \n */\n\nimport { compareNodeNames, toElement, moveChildren, createElementNS, doc } from './util';\nimport specialElHandlers from './specialElHandlers';\nimport { format } from 'path-browserify';\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nexport default function morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n          toNode = toNode.firstElementChild;\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    // if we find a duplicate #id node in cache, replace `el` with cache value\n                    // and morph it to the child node.\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    } else {\n                      handleNodeAdded(curChild);\n                    }\n                } else {\n                  // recursively call for curChild and it's children to see if we find something in\n                  // fromNodesLookup\n                  handleNodeAdded(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // @jembeModification\n                                // If the two nodes are different, but the next element is an exact match,\n                                // we can assume that the new node is meant to be inserted, instead of\n                                // used as a morph target.\n                                // original at: https://github.com/livewire/livewire/blob/master/js/dom/morphdom/morphdom.js\n                                if (\n                                    ! curToNodeChild.isEqualNode(curFromNodeChild)\n                                    && curToNodeChild.nextElementSibling\n                                    && curToNodeChild.nextElementSibling.isEqualNode(curFromNodeChild)\n                                ) {\n                                    isCompatible = false\n                                } else {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    // MORPH\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // @jembeModification\n                    // Before we just remove the original element, let's see if it's the very next\n                    // element in the \"to\" list. If it is, we can assume we can insert the new\n                    // element before the original one instead of removing it. This is kind of\n                    // a \"look-ahead\".\n                    // original at: https://github.com/livewire/livewire/blob/master/js/dom/morphdom/morphdom.js\n                    if (curToNodeChild.nextElementSibling && curToNodeChild.nextElementSibling.isEqualNode(curFromNodeChild)) {\n                        const nodeToBeAdded = curToNodeChild.cloneNode(true)\n                        fromEl.insertBefore(nodeToBeAdded, curFromNodeChild)\n                        handleNodeAdded(nodeToBeAdded)\n                        curToNodeChild = curToNodeChild.nextElementSibling.nextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    } else {\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n                    }\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n","import morphAttrs from './morphAttrs';\nimport morphdomFactory from './morphdom';\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;","import ComponentAPI from \"./componentApi/index.js\";\nimport { deepCopy, walkComponentDom, getCookie } from \"./utils.js\";\nimport morphdom from \"./morphdom/index.js\";\nimport { walk, saferEvalNoReturn } from \"./componentApi/utils.js\";\nimport JMB from \"./componentApi/magic/jmb.js\";\n\n/**\n * Reference to component html with associated data\n */\nclass ComponentRef {\n  constructor(jembeClient, execName, data, dom, onDocument) {\n    this.jembeClient = jembeClient;\n\n    this.execName = execName;\n    this.hierarchyLevel = execName.split(\"/\").length;\n    this.isPageComponent = this.hierarchyLevel === 2;\n\n    this.state = data.state;\n    this.url = data.url;\n    this.changesUrl = data.changesUrl;\n    this.actions = data.actions !== undefined ? data.actions : {};\n    this.dom = this._cleanDom(dom);\n    this.onDocument = onDocument;\n\n    this.placeHolders = {};\n    this.permanentPlaceHolders = {};\n    this.api = null;\n  }\n  mount(originalComponentRef = undefined) {\n    this._getPlaceHolders();\n    if (this.api === null) {\n      this.api = new ComponentAPI(this);\n    }\n    this.api.mount(originalComponentRef);\n    this._add_support_for_jmb_changed_attr_to_inputs();\n  }\n  remove() {\n    // let removed = []\n    // for (const [execName, domElement] of Object.entries(this.placeHolders)) {\n    //   removed.push(execName)\n    //   domElement.remove()\n    // }\n    const dom = this.dom;\n    this.unmount();\n    dom.remove();\n    return this.execName;\n    // removed.push(this.execName)\n    // return removed\n  }\n  unmount() {\n    if (this.api !== null) {\n      this.api.unmount();\n    }\n    this.api = null;\n    this.dom = null;\n  }\n  toJsonRequest() {\n    return {\n      execName: this.execName,\n      state: this.state,\n    };\n  }\n\n  merge(parentComponent, originalComponent) {\n    if (this.isPageComponent && this.onDocument) {\n      // if page component is already on document do nothing\n      // because it is already mounted and it's not changed\n      return;\n    }\n    if (\n      this.onDocument &&\n      originalComponent !== undefined &&\n      originalComponent.dom.isSameNode(this.dom) &&\n      Object.keys(parentComponent.placeHolders).includes(this.execName)\n    ) {\n      // no need to unmount-merge-mount component that is already on document\n      if (!parentComponent.placeHolders[this.execName].isSameNode(this.dom)) {\n        // but if parent is changed we need to update parent place holders\n        parentComponent.placeHolders[this.execName].replaceWith(this.dom);\n        parentComponent.placeHolders[this.execName] = this.dom;\n      }\n      return;\n    }\n\n    if (this.isPageComponent) {\n      let documentElement = this.jembeClient.document.documentElement;\n      this.dom = documentElement = this._morphdom(documentElement, this.dom);\n      this.dom.setAttribute(\"jmb-name\", this.execName);\n    } else {\n      if (Object.keys(parentComponent.placeHolders).includes(this.execName)) {\n        this.dom = this._morphdom(\n          parentComponent.placeHolders[this.execName],\n          this.dom\n        );\n        parentComponent.placeHolders[this.execName] = this.dom;\n      } else {\n        // adding to permanent placeholder\n        const placeholderEl = document.createElement(\"template\");\n        placeholderEl.setAttribute(\"jmb-placeholder\", this.execName);\n        const newPlaceholder = parentComponent.permanentPlaceHolders[\n          this.execName\n        ].insertAdjacentElement(\"afterend\", placeholderEl);\n        this.dom = this._morphdom(newPlaceholder, this.dom);\n        parentComponent.placeHolders[this.execName] = this.dom;\n      }\n    }\n\n    this.onDocument = true;\n\n    this.mount(\n      originalComponent !== undefined &&\n        originalComponent.execName === this.execName\n        ? originalComponent\n        : undefined\n    );\n  }\n\n  _morphdom(from, to) {\n    return morphdom(from, to, {\n      getNodeKey: (node) => {\n        return node.nodeType === Node.ELEMENT_NODE &&\n          node.hasAttribute(\"jmb-name\")\n          ? node.getAttribute(\"jmb-name\")\n          : node.id;\n      },\n      onBeforeElUpdated: (fromEl, toEl) => {\n        // spec - https://dom.spec.whatwg.org/#concept-node-equals\n        if (fromEl.isEqualNode(toEl)) {\n          return false;\n        }\n        // don't pass to next component or template\n        if (\n          !this.isPageComponent &&\n          fromEl.hasAttribute(\"jmb-name\") &&\n          fromEl.getAttribute(\"jmb-name\") !== this.execName\n        )\n          return false;\n        if (\n          fromEl.hasAttribute(\"jmb-placeholder\") &&\n          fromEl.getAttribute(\"jmb-placeholder\") !== this.execName\n        )\n          return false;\n        if (fromEl.hasAttribute(\"jmb-ignore\")) {\n          return false;\n        }\n        return true;\n      },\n      onBeforeNodeDiscarded: (node) => {\n        // consolo leog in jmb-on-remove:\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          let removes = node.querySelectorAll(\"[jmb-on-remove]\");\n          for (const rnode of removes) {\n            saferEvalNoReturn(\n              rnode,\n              rnode.getAttribute(\"jmb-on-remove\"),\n              {},\n              {\n                $self: rnode,\n              }\n            );\n          }\n        }\n        return true;\n      },\n      childrenOnly: this.isPageComponent,\n    });\n  }\n  _getPlaceHolders() {\n    this.placeHolders = {};\n    this.permanentPlaceHolders = {};\n    walkComponentDom(\n      this.dom,\n      (el) => {\n        if (el.hasAttribute(\"jmb-placeholder-permanent\")) {\n          this.permanentPlaceHolders[\n            el.getAttribute(\"jmb-placeholder-permanent\")\n          ] = el;\n        }\n      },\n      (el, execName) => {\n        // populate placeHolders\n        this.placeHolders[execName] = el;\n      }\n    );\n  }\n  _cleanDom(dom) {\n    // if html dom has only one child use that child to put jmb-name tag\n    // if not enclose html with div and put jmb-name into it\n    if (typeof dom === \"string\") {\n      let domString = dom.trim();\n      if (!this.isPageComponent) {\n        let template = this.jembeClient.document.createElement(\"template\");\n        template.innerHTML = domString;\n        // check is it needed to add souranding DIV tag\n        if (\n          template.content.childNodes.length > 1 ||\n          template.content.childNodes.length === 0 ||\n          template.content.firstChild.nodeType === Node.TEXT_NODE ||\n          (template.content.childNodes.length === 1 &&\n            (template.content.firstChild.hasAttribute(\"jmb-name\") ||\n              template.content.firstChild.hasAttribute(\"jmb-placeholder\")))\n        ) {\n          let div = this.jembeClient.document.createElement(\"div\");\n          let curChild = template.content.firstChild;\n          while (curChild) {\n            let nextChild = curChild.nextSibling;\n            div.appendChild(curChild);\n            curChild = nextChild;\n          }\n          template.content.appendChild(div);\n        }\n        // add jmb-name tag\n        template.content.firstChild.setAttribute(\"jmb-name\", this.execName);\n        dom = template.content.firstChild;\n      } else {\n        const doc = this.jembeClient.domParser.parseFromString(\n          domString,\n          \"text/html\"\n        );\n        doc.documentElement.setAttribute(\"jmb-name\", this.execName);\n        dom = doc.documentElement;\n      }\n    }\n    dom.removeAttribute(\"jmb-data\");\n    return dom;\n  }\n  _add_support_for_jmb_changed_attr_to_inputs() {\n    // when input is changed add jmb-input-changed attribute\n    // so that morphdom will pickup the change and update it\n    // with new value (jembe treats input value as actual/live value instead of default value)\n    for (const inputEl of this.dom.querySelectorAll(\"input\")) {\n      inputEl.removeEventListener(\n        \"change\",\n        this._jmb_input_changed_attr_listener,\n        false\n      );\n      inputEl.addEventListener(\n        \"change\",\n        this._jmb_input_changed_attr_listener,\n        false\n      );\n    }\n  }\n  _jmb_input_changed_attr_listener(event) {\n    event.target.setAttribute(\"jmb-input-changed\", \"\");\n  }\n}\n\nclass UploadedFile {\n  constructor(execName, paramName, fileUploadId, files) {\n    this.execName = execName;\n    this.paramName = paramName;\n    this.fileUploadId = fileUploadId;\n    this.files = files;\n    this.multipleFiles = files instanceof FileList || files instanceof Array;\n  }\n  addToFormData(formData) {\n    if (this.multipleFiles) {\n      for (const file of this.files) {\n        formData.append(this.fileUploadId, file);\n      }\n    } else {\n      formData.append(this.fileUploadId, this.files);\n    }\n  }\n}\n/**\n * Handle all jembe logic on client side, primarly building, sending, processing\n * and refreshing page for/on x-jembe requests\n */\nclass JembeClient {\n  constructor(doc = document) {\n    this.document = doc;\n    this.components = {};\n    this.getComponentsFromDocument();\n    this.updateLocation(true);\n    this.commands = [];\n    this.filesForUpload = {};\n    this.domParser = new DOMParser();\n    this.xRequestUrl = null;\n\n    this.xRequestsInProgress = 0;\n    this.xRequestActiveElement = null;\n    this.xRequestDisabledElements = [];\n    this.disableInputBeforeRequestTimeoutId = null;\n\n    window.onpopstate = this.onHistoryPopState;\n\n    // support adding x-jembe request headers\n    this.xRequestHeadersGenerators = [];\n  }\n  /**\n   * Finds all jmb-name and associate jmb-data tags in document\n   * and create ComponentRefs\n   */\n  getComponentsFromDocument() {\n    this.components = {};\n    let componentsNodes = this.document.querySelectorAll(\n      \"[jmb-name][jmb-data]\"\n    );\n    for (const componentNode of componentsNodes) {\n      const componentRef = new ComponentRef(\n        this,\n        componentNode.getAttribute(\"jmb-name\"),\n        eval(`(${componentNode.getAttribute(\"jmb-data\")})`),\n        componentNode,\n        true\n      );\n      this.components[componentRef.execName] = componentRef;\n      componentRef.mount();\n    }\n  }\n  /**\n   * Create dict of {execName:component} for all components find in\n   * x-jembe response\n   * @param {*} xJembeResponse\n   */\n  getComponentsAndGlobalsFromXResponse(xJembeResponse) {\n    let components = {};\n    let globals = {\n      removeComponents: [],\n      callWindowOpen: [],\n    };\n    for (const xComp of xJembeResponse) {\n      if (Object.keys(xComp).includes(\"globals\")) {\n        // this block is not component but\n        // contains global response information\n        globals = {\n          removeComponents:\n            xComp.removeComponents !== undefined ? xComp.removeComponents : [],\n          callWindowOpen:\n            xComp.callWindowOpen !== undefined ? xComp.callWindowOpen : [],\n        };\n      } else {\n        const dom = xComp.dom;\n        components[xComp.execName] = new ComponentRef(\n          this,\n          xComp.execName,\n          {\n            url: xComp.url,\n            changesUrl: xComp.changesUrl,\n            state: xComp.state,\n            actions: xComp.actions,\n          },\n          xComp.dom,\n          false\n        );\n      }\n    }\n    return { components: components, globals: globals };\n  }\n  /**\n   * Update document with new components:dict\n   * @param {} components\n   */\n  updateDocument({ components, globals }) {\n    // make list of all existing components that can be display on updated document\n    // list contains all from this.components merged with components where\n    // if there is components with same execname one from components is used\n    let currentComponents = {};\n    // add from this.components if not exist in components otherwise add from components\n    for (const [execName, compRef] of Object.entries(this.components)) {\n      if (components[execName] === undefined) {\n        currentComponents[execName] = compRef;\n      } else {\n        currentComponents[execName] = components[execName];\n      }\n    }\n    // add from components if not already added\n    for (const [execName, compRef] of Object.entries(components)) {\n      if (currentComponents[execName] === undefined) {\n        currentComponents[execName] = compRef;\n      }\n    }\n    //process current components one by one starting with root page\n    // all components gatthered from document but whitout its placeholder\n    // will be ignored.\n    // chose root/page component from compoents if it exist otherwise use\n    // one on the document\n    let pageExecNames = Object.values(currentComponents)\n      .filter((c) => c.isPageComponent)\n      .map((c) => c.execName);\n    // execName of new pageComponent\n    let pageExecName = pageExecNames[0];\n    if (pageExecNames.length > 1) {\n      for (const pen of pageExecNames) {\n        if (!currentComponents[pen].onDocument) {\n          pageExecName = pen;\n        }\n      }\n    }\n    let processingExecNames = [pageExecName];\n    let newComponents = {};\n    while (processingExecNames.length > 0) {\n      const currentComponent = currentComponents[processingExecNames.shift()];\n      if (currentComponent !== undefined) {\n        let orignalComponent = this.components[currentComponent.execName];\n        let parentComponent = Object.values(newComponents).find(\n          (c) =>\n            Object.keys(c.placeHolders).includes(currentComponent.execName) ||\n            Object.keys(c.permanentPlaceHolders).includes(\n              currentComponent.execName\n            )\n        );\n        currentComponent.merge(parentComponent, orignalComponent);\n        newComponents[currentComponent.execName] = currentComponent;\n        for (const placeHolderName of Object.keys(\n          currentComponent.placeHolders\n        )) {\n          processingExecNames.push(placeHolderName);\n        }\n        for (const permanentPlaceHolderName of Object.keys(\n          currentComponent.permanentPlaceHolders\n        )) {\n          if (\n            !Object.keys(currentComponent.placeHolders).includes(\n              permanentPlaceHolderName\n            )\n          ) {\n            processingExecNames.push(permanentPlaceHolderName);\n          }\n        }\n      }\n    }\n    // unmount components that will be removed\n    for (const [execName, component] of Object.entries(this.components)) {\n      if (\n        !Object.keys(newComponents).includes(execName) ||\n        newComponents[execName] !== component\n      ) {\n        component.unmount();\n      }\n    }\n    // unmount and remove components from globals.removeComponents list\n    let removedComponents = [];\n    let execName;\n    while (typeof (execName = globals.removeComponents.pop()) !== \"undefined\") {\n      if (\n        Object.keys(newComponents).includes(execName) &&\n        !removedComponents.includes(execName)\n      ) {\n        for (const childExecName of Object.keys(\n          newComponents[execName].placeHolders\n        )) {\n          globals.removeComponents.push(childExecName);\n        }\n        removedComponents.push(newComponents[execName].remove());\n        const parentComponentExecName = execName\n          .split(\"/\")\n          .slice(0, -1)\n          .join(\"/\");\n        delete newComponents[parentComponentExecName].placeHolders[execName];\n      }\n    }\n    for (const rmExecName of removedComponents) {\n      delete newComponents[rmExecName];\n    }\n    // call window open from globals.callWindowOpen\n    for (const url of globals.callWindowOpen) {\n      window.open(url, \"_blank\");\n    }\n\n    this.components = newComponents;\n  }\n\n  addInitialiseCommand(execName, initParams, mergeExistingParams = true) {\n    const exisitingInitCommands = this.commands.filter(\n      (x) => x.type === \"init\" && x.componentExecName === execName\n    );\n    if (mergeExistingParams === true && exisitingInitCommands.length > 0) {\n      const existingCmd = exisitingInitCommands[0];\n      for (const [paramName, paramValue] of Object.entries(initParams)) {\n        existingCmd.initParams = this._updateParam(\n          existingCmd.initParams,\n          paramName,\n          paramValue\n        );\n      }\n    } else {\n      if (\n        mergeExistingParams === true &&\n        Object.keys(initParams).length === 0 &&\n        this.components[execName] !== undefined\n      ) {\n        // dont add init command for existing components if no params are changed\n        return;\n      }\n      let params =\n        mergeExistingParams === true && this.components[execName] !== undefined\n          ? deepCopy(this.components[execName].state)\n          : {};\n      for (const [paramName, paramValue] of Object.entries(initParams)) {\n        params = this._updateParam(params, paramName, paramValue);\n      }\n      if (mergeExistingParams === false && exisitingInitCommands > 0) {\n        const existingCmd = exisitingInitCommands[0];\n        existingCmd.initParams = params;\n        existingCmd.mergeExistingParams = mergeExistingParams;\n      } else {\n        this.commands.push({\n          type: \"init\",\n          componentExecName: execName,\n          initParams: params,\n          mergeExistingParams: mergeExistingParams,\n        });\n      }\n    }\n  }\n  /**\n   * Update params with [paramName] =  paramValue\n   * paramName can contain dots (.) to separate object attributes\n   * @param {dict} params\n   * @param {string} paramName\n   * @param {*} paramValue\n   */\n  _updateParam(params, paramName, paramValue) {\n    if (paramName.startsWith(\".\") || paramName.endsWith(\".\")) {\n      throw \"paramName cant start or end in dot (.)\";\n    }\n    return this._updateParamR(params, paramName.split(\".\"), paramValue);\n  }\n  _updateParamR(params, paramNames, paramValue) {\n    let pName = paramNames[0];\n    if (paramNames.length === 1) {\n      // last element\n      params[pName] = paramValue;\n    } else if (params[pName] === undefined) {\n      params[pName] = this._updateParamR({}, paramNames.slice(1), paramValue);\n    } else {\n      params[pName] = this._updateParamR(\n        params[pName],\n        paramNames.slice(1),\n        paramValue\n      );\n    }\n    return params;\n  }\n\n  addCallCommand(execName, actionName, args = [], kwargs = {}) {\n    const exisitingCallIndex = this.commands.findIndex(\n      (x) =>\n        x.type === \"call\" &&\n        x.componentExecName === execName &&\n        x.actionName === actionName &&\n        JSON.stringify(x.args) === JSON.stringify(args) &&\n        JSON.stringify(x.kwargs) === JSON.stringify(kwargs)\n    );\n    if (exisitingCallIndex >= 0) {\n      this.commands.splice(exisitingCallIndex, 1);\n    }\n    this.commands.push({\n      type: \"call\",\n      componentExecName: execName,\n      actionName: actionName,\n      args: args,\n      kwargs: kwargs,\n    });\n  }\n  addEmitCommand(execName, eventName, kwargs = {}, to = null) {\n    this.commands.push({\n      type: \"emit\",\n      componentExecName: execName,\n      eventName: eventName,\n      params: kwargs,\n      to: to,\n    });\n  }\n  addFilesForUpload(execName, paramName, files) {\n    // remove existing files for same param name\n    let existingFileId = null;\n    for (const uf of Object.values(this.filesForUpload)) {\n      if (uf.execName === execName && uf.paramName === paramName) {\n        existingFileId = uf.fileUploadId;\n      }\n    }\n    if (existingFileId !== null) {\n      delete this.filesForUpload[existingFileId];\n    }\n\n    if (\n      ((files instanceof FileList || files instanceof Array) &&\n        files.length > 0) ||\n      files instanceof File\n    ) {\n      // add files to paramName\n      let fileId = null;\n      while (\n        fileId == null ||\n        Object.keys(this.filesForUpload).includes(fileId)\n      ) {\n        fileId = Math.random().toString(36).substring(7);\n      }\n      this.filesForUpload[fileId] = new UploadedFile(\n        execName,\n        paramName,\n        fileId,\n        files\n      );\n      // add init command if not exist\n      this.addInitialiseCommand(execName, {\n        [paramName]: fileId,\n      });\n    } else {\n      // remove init command if only containt file init param\n      let initCommandIndex = this.commands.findIndex(\n        (cmd) =>\n          cmd.componentExecName === execName &&\n          cmd.type === \"init\" &&\n          Object.keys(cmd.initParams).includes(paramName) &&\n          Object.keys(cmd.initParams).length === 1\n      );\n      if (initCommandIndex >= 0) {\n        this.commands.splice(initCommandIndex, 1);\n      }\n    }\n  }\n  getXUploadRequestFormData() {\n    if (Object.keys(this.filesForUpload).length === 0) {\n      // no files for uplaod\n      return null;\n    }\n    let fd = new FormData();\n    for (const uf of Object.values(this.filesForUpload)) {\n      uf.addToFormData(fd);\n    }\n    return fd;\n  }\n  getXRequestJson(addComponents = true) {\n    return JSON.stringify({\n      components: addComponents? Object.values(this.components).map((x) => x.toJsonRequest()) : [],\n      commands: this.commands,\n    });\n  }\n  setXRequestUrl(url) {\n    this.xRequestUrl = url;\n  }\n  executeUpload() {\n    const url = \"/jembe/upload_files\";\n    const uploadFormData = this.getXUploadRequestFormData();\n    if (uploadFormData === null) {\n      return new Promise((resolve, reject) => {\n        resolve(null);\n      });\n    }\n    const headers =\n      this.xRequestHeadersGenerators.length === 0\n        ? {}\n        : this.calculateXRequestHeaders();\n    headers[\"X-JEMBE\"] = \"upload\";\n    return window\n      .fetch(url, {\n        method: \"POST\",\n        cache: \"no-cache\",\n        credentials: \"same-origin\",\n        redirect: \"follow\",\n        referrer: \"no-referrer\",\n        headers: headers,\n        body: uploadFormData,\n      })\n      .then((response) => {\n        if (!response.ok) {\n          this.dispatchUpdatePageErrorEvent(response, null, false);\n          console.log(\"Error in x-jmebe upload response\");\n          throw Error(\"errorInJembeResponse\");\n        }\n        return response.json();\n      })\n      .then((json) => {\n        // fileupload returns files = dict(fileUploadId, [{storage=storage_name, path=file_path}]) and unique fileUplaodResponseId\n        for (const fileUploadId of Object.keys(json.files)) {\n          // replace all uploaded files init params with\n          //(storage=storage_name, path=file_path) returned from x-jembe=fileupload request\n          const ufiles = json.files[fileUploadId];\n          const fu = this.filesForUpload[fileUploadId];\n          this.addInitialiseCommand(fu.execName, {\n            [fu.paramName]: fu.multipleFiles ? ufiles : ufiles[0],\n          });\n        }\n\n        this.filesForUpload = {};\n        return json.fileUploadResponseId;\n      });\n  }\n  executeCommands(disableInputs = true, updateLocation = true, addComponents = true) {\n    const url =\n      this.xRequestUrl !== null ? this.xRequestUrl : window.location.href;\n    this.dispatchStartUpdatePageEvent(true, disableInputs);\n    this.executeUpload()\n      .then((fileUploadResponseId) => {\n        const requestBody = this.getXRequestJson(addComponents);\n        // reset commads since we create request body from it\n        this.commands = [];\n        const headers =\n          this.xRequestHeadersGenerators.length === 0\n            ? {}\n            : this.calculateXRequestHeaders();\n        headers[\"X-JEMBE\"] = \"commands\";\n        if (fileUploadResponseId !== null) {\n          headers[\"X-JEMBE-RELATED-UPLOAD\"] = fileUploadResponseId;\n        }\n        // fetch request and process response\n        window\n          .fetch(url, {\n            method: \"POST\",\n            cache: \"no-cache\",\n            credentials: \"same-origin\",\n            redirect: \"follow\",\n            referrer: \"no-referrer\",\n            headers: headers,\n            body: requestBody,\n          })\n          .then((response) => {\n            if (!response.ok) {\n              if (disableInputs) {\n                this.xRequestsInProgress -= 1;\n                this.enableInputsAfterResponse();\n              }\n              console.info(\"Error x-jembe response\", response);\n              this.dispatchUpdatePageErrorEvent(response, null, disableInputs);\n              throw Error(\"errorInJembeResponse\");\n            }\n            return response.json();\n          })\n          .then((json) => this.getComponentsAndGlobalsFromXResponse(json))\n          .then((componentsAndGlobals) => {\n            this.updateDocument(componentsAndGlobals);\n            if (updateLocation && disableInputs) {\n              this.updateLocation();\n            }\n            if (disableInputs) {\n              this.xRequestsInProgress -= 1;\n              this.enableInputsAfterResponse();\n            }\n            this.dispatchUpdatePageEvent(true, disableInputs, this.components);\n          })\n          .catch((error) => {\n            if (error.message != \"errorInJembeResponse\") {\n              console.info(\"Error x-jembe request\", error);\n              this.dispatchUpdatePageErrorEvent(null, error, disableInputs);\n            }\n            if (disableInputs) {\n              this.xRequestsInProgress -= 1;\n              this.enableInputsAfterResponse();\n            }\n          });\n      })\n      .catch((error) => {\n        if (error.message != \"errorInJembeResponse\") {\n          console.info(\"Error x-jembe request\", error);\n          this.dispatchUpdatePageErrorEvent(null, error, disableInputs);\n        }\n        if (disableInputs) {\n          this.xRequestsInProgress -= 1;\n          this.enableInputsAfterResponse();\n        }\n      });\n  }\n  updateLocation(replace = false) {\n    // TODO non blocking x request should not update location\n    let topComponent = null;\n    let level = -1;\n    let historyState = [];\n    for (const component of Object.values(this.components)) {\n      if (component.hierarchyLevel > level && component.changesUrl === true) {\n        topComponent = component;\n        level = component.hierarchyLevel;\n      }\n      // historyState.push({\n      //   execName: component.execName,\n      //   state: component.state,\n      // });\n      historyState.push(component.toJsonRequest());\n    }\n    if (topComponent !== null) {\n      if (replace) {\n        window.history.replaceState(historyState, \"\", topComponent.url);\n      } else {\n        window.history.pushState(historyState, \"\", topComponent.url);\n      }\n    }\n  }\n  onHistoryPopState(event) {\n    if (event.state === null) {\n      window.location = document.location;\n    } else {\n      for (const comp of event.state) {\n        this.jembeClient.addInitialiseCommand(comp.execName, comp.state, false);\n      }\n      let execNames = event.state.map((x) => x.execName);\n      execNames = execNames.sort(\n        (a, b) => b.split(\"/\").length - a.split(\"/\").length\n      );\n      for (const en of execNames) {\n        this.jembeClient.addCallCommand(en, \"display\");\n      }\n      this.jembeClient.executeCommands(true, false, false);\n    }\n  }\n  /**\n   * Used for geting jembeCompoentApi usually attached to document or window.jembeComponent\n   * @param {*} domNode\n   */\n  component(domNode) {\n    const componentExecName = domNode\n      .closest(\"[jmb-name]\")\n      .getAttribute(\"jmb-name\");\n    return new JMB(this, componentExecName);\n  }\n\n  dispatchUpdatePageEvent(\n    isXUpdate = true,\n    inputsDisabled = true,\n    components = {}\n  ) {\n    window.dispatchEvent(\n      new CustomEvent(\"jembeUpdatePage\", {\n        detail: {\n          isXUpdate: isXUpdate,\n          inputsDisabled: inputsDisabled,\n          components: Object.fromEntries(\n            Object.entries(components).map(([key, val]) => [key, val.dom])\n          ),\n        },\n      })\n    );\n  }\n  dispatchStartUpdatePageEvent(isXUpdate = true, disableInputs = true) {\n    if (disableInputs && isXUpdate) {\n      this.xRequestsInProgress += 1;\n      if (this.xRequestsInProgress === 1) {\n        this.disableInputBeforeRequestTimeoutId = window.setTimeout(() => {\n          this.disableInputsBeforeRequest();\n        }, 50);\n      }\n    }\n    window.dispatchEvent(\n      new CustomEvent(\"jembeStartUpdatePage\", {\n        detail: {\n          isXUpdate: isXUpdate,\n          inputsDisabled: disableInputs,\n        },\n      })\n    );\n  }\n  dispatchUpdatePageErrorEvent(\n    response = null,\n    error = null,\n    inputsDisabled = true\n  ) {\n    window.dispatchEvent(\n      new CustomEvent(\"jembeUpdatePageError\", {\n        detail: {\n          inputsDisabled: inputsDisabled,\n          networkError: error !== null,\n          response: response,\n          error: error,\n        },\n      })\n    );\n  }\n  disableInputsBeforeRequest() {\n    // save currently focused element\n    if (this.document.activeElement !== null) {\n      this.xRequestActiveElement = this.document.activeElement;\n    }\n    // walk over whole document and disable inputs\n    walk(this.document.documentElement, (node) => {\n      if (node.hasAttribute(\"jmb-ignore\")) return false;\n      if (\n        // <button>\n        node.tagName.toLowerCase() === \"button\" ||\n        // <select>\n        node.tagName.toLowerCase() === \"select\" ||\n        // <input type=\"checkbox|radio\">\n        (node.tagName.toLowerCase() === \"input\" &&\n          (node.type === \"checkbox\" || node.type === \"radio\"))\n      ) {\n        node.setAttribute(\"jmb-node-initially-disabled\", node.disabled);\n        if (!node.disabled) {\n          node.disabled = true;\n          this.xRequestDisabledElements.push(() => {\n            if (node.hasAttribute(\"jmb-node-initially-disabled\")) {\n              node.disabled =\n                node.getAttribute(\"jmb-node-initially-disabled\") === \"true\";\n              node.removeAttribute(\"jmb-node-initially-disabled\");\n            }\n          });\n        }\n      } else if (\n        // <input type=\"text\">\n        node.tagName.toLowerCase() === \"input\" ||\n        // <textarea>\n        node.tagName.toLowerCase() === \"textarea\"\n      ) {\n        node.setAttribute(\"jmb-node-initially-readonly\", node.readOnly);\n        node.setAttribute(\"jmb-node-initially-disabled\", node.disabled);\n        if (!node.readOnly) {\n          node.readOnly = true;\n          node.disabled = true;\n          this.xRequestDisabledElements.push(() => {\n            if (node.hasAttribute(\"jmb-node-initially-readonly\")) {\n              node.readOnly =\n                node.getAttribute(\"jmb-node-initially-readonly\") === \"true\";\n              node.removeAttribute(\"jmb-node-initially-readonly\");\n            }\n            if (node.hasAttribute(\"jmb-node-initially-disabled\")) {\n              node.disabled =\n                node.getAttribute(\"jmb-node-initially-disabled\") === \"true\";\n              node.removeAttribute(\"jmb-node-initially-disabled\");\n            }\n          });\n        }\n      }\n    });\n  }\n  enableInputsAfterResponse() {\n    window.clearTimeout(this.disableInputBeforeRequestTimeoutId);\n    if (this.xRequestsInProgress !== 0) {\n      return;\n    }\n    //enable disabled inputs (not updated by morph)\n    for (let f of this.xRequestDisabledElements) {\n      f();\n    }\n    this.xRequestDisabledElements = [];\n    // refocus active element\n    if (\n      this.xRequestActiveElement !== null &&\n      this.document.contains(this.xRequestActiveElement)\n    ) {\n      this.xRequestActiveElement.focus();\n    }\n    this.xRequestActiveElement = null;\n  }\n  addXRequestHeaderGenerator(callback) {\n    this.xRequestHeadersGenerators.push(callback);\n  }\n  calculateXRequestHeaders() {\n    let header = {};\n    for (const headerGenCallback of this.xRequestHeadersGenerators) {\n      header = { ...header, ...headerGenCallback() };\n    }\n    return header;\n  }\n  getCookie(name) {\n    return getCookie(name);\n  }\n  walkComponent(component, callback) {\n    if (component instanceof String) {\n      component = this.document.querySelector(`[jmb-name=${component}]`);\n    }\n    walkComponentDom(component, callback);\n  }\n  walkDocument(callback) {\n    walk(this.document.documentElement, callback);\n  }\n}\n\nexport { JembeClient };\n","import { JembeClient } from \"./client.js\";\nwindow.jembeClient = new JembeClient(document)\nwindow.jembeClient.dispatchUpdatePageEvent(false, false)"]}